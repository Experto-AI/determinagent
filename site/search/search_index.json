{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DeterminAgent","text":"<p>CLI-First Deterministic Multi-Agent Orchestration Library</p> <p> </p> <p>Orchestrate powerful AI workflows at zero extra cost. DeterminAgent controls multiple AI CLI tools (Claude Code, GH Copilot, Gemini CLI, OpenAI Codex) using LangGraph to create deterministic pipelines powered by your existing flat-rate subscriptions.</p>"},{"location":"#first-contact","title":"\ud83d\ude80 First Contact","text":"<p>DeterminAgent is a Python library for developers who want to build complex, multi-agent systems without paying for expensive per-token API calls. By wrapping the CLI tools you already pay for, DeterminAgent allows you to build production-grade workflows for $0 in variable costs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Library-Only: Full control in pure Python. No proprietary YAML DSL.</li> <li>Subscription Arbitrage: Uses your flat-rate CLI subscriptions.</li> <li>Deterministic: Powered by LangGraph state machines.</li> <li>Zero-Latency: Controls local tools via subprocess.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install determinagent\n</code></pre>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>At least one supported AI CLI tool installed and authenticated:</li> <li>Claude Code (<code>claude</code>)</li> <li>GitHub Copilot CLI (<code>gh copilot</code>)</li> <li>Gemini CLI (<code>gemini</code>)</li> <li>OpenAI Codex (<code>codex</code>)</li> </ul>"},{"location":"#quick-start","title":"\u26a1 Quick Start","text":""},{"location":"#library-usage","title":"Library Usage","text":"<pre><code>from determinagent import UnifiedAgent, SessionManager\n\n# Create a deterministic agent\nwriter = UnifiedAgent(\n    provider=\"claude\",\n    model=\"balanced\",\n    role=\"Technical Blogger\",\n    session=SessionManager(\"claude\")\n)\n\n# Send a prompt - zero per-token cost!\nresponse = writer.send(\"Explain LangGraph in 3 sentences.\")\nprint(response)\n</code></pre>"},{"location":"#template-flows","title":"Template Flows","text":"<p>Don't start from scratch. Use our pre-built Python templates in the <code>flows/</code> directory: - <code>flows/blog/</code>: Complete Writer \u2192 Editor \u2192 Reviewer workflow with human review.</p> <p>To run the blog flow: <pre><code>python flows/blog/main.py \"My Blog Topic\" --writer claude --editor copilot\n</code></pre></p>"},{"location":"#compatibility-matrix","title":"\ud83e\udde9 Compatibility Matrix","text":"Provider Adapter Status Session Support Web Search Native Models Claude Code \u2705 Stable \u2705 Native \u2705 Yes fast, balanced, powerful GH Copilot \u2705 Stable \u2705 Native \u2705 Yes fast, balanced, powerful Gemini CLI \u2705 Beta \u2705 Native \u2705 Yes flash, pro OpenAI Codex \u2705 Beta \u2705 Native \u274c No fast, balanced"},{"location":"#troubleshooting","title":"\ud83d\udee0\ufe0f Troubleshooting","text":""},{"location":"#common-issues","title":"Common Issues","text":"<ol> <li><code>ProviderNotAvailable: CLI command 'claude' not found</code></li> <li>Ensure the tool is installed and available in your <code>$PATH</code>.</li> <li> <p>Run <code>claude --version</code> manually to verify.</p> </li> <li> <p>Authentication Errors</p> </li> <li> <p>DeterminAgent uses your local sessions. Ensure you are logged in to the CLI tool (e.g., <code>gh auth status</code> or <code>claude login</code>).</p> </li> <li> <p>Subprocess Timeouts</p> </li> <li>Some agents (like Writer) can take a few minutes for long content. Ensure your environment doesn't kill long-running processes.</li> </ol>"},{"location":"#debug-mode","title":"Debug Mode","text":"<p>Set <code>LOG_LEVEL=DEBUG</code> to see the full subprocess commands and raw output.</p>"},{"location":"#documentation","title":"\ud83d\udcd6 Documentation","text":"<ul> <li>Project Roadmap: Current status and next steps.</li> <li>Technical Architecture: Design principles and internals.</li> <li>CLI Reference: Low-level flag mappings.</li> <li>Contributing: How to help improve the project.</li> </ul>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>Apache License 2.0 - see LICENSE for details.</p>"},{"location":"architecture/","title":"DeterminAgent Architecture &amp; Technical Design","text":"<p>Version: 3.0 Status: Technical Source of Truth Target Audience: Developers &amp; Contributors</p>"},{"location":"architecture/#1-design-principles","title":"1. Design Principles","text":""},{"location":"architecture/#the-library-first-philosophy","title":"The Library-First Philosophy","text":"<p>DeterminAgent is a library, not a framework. It provides clean Pythonic abstractions over AI CLI tools without forcing a proprietary workflow engine. - Full Control: Users write standard Python and LangGraph code. - Type Safety: Pydantic models and strict type hinting for all public APIs. - Testability: Designed for local unit testing without expensive API calls.</p>"},{"location":"architecture/#the-strict-output-pattern","title":"The Strict Output Pattern","text":"<p>When orchestrating multi-agent systems, \"meta-commentary\" (e.g., \"I've updated the code for you...\") breaks downstream agents. Every prompt must include strict output rules: <pre><code>CRITICAL OUTPUT RULES:\n1. Start DIRECTLY with the content (e.g., \"# Title\" for blog, \"import\" for code)\n2. Do NOT include ANY introductory text (e.g., \"I've created...\", \"Sure, here is...\")\n3. Do NOT include ANY closing remarks (e.g., \"I hope this helps\", \"Let me know...\")\n4. Output ONLY the raw content. Nothing else.\n</code></pre></p>"},{"location":"architecture/#2-value-proposition","title":"2. Value Proposition","text":""},{"location":"architecture/#the-three-pillars","title":"The Three Pillars","text":"<ol> <li>Finite State Orchestration: Replaces unpredictable autonomous agents with deterministic, graph-based logic using LangGraph.</li> <li>Subscription Arbitrage: $0 additional cost by leveraging flat-rate CLI subscriptions (no per-token API charges).</li> <li>Binary-First Integration: Directly controls local CLI tools via subprocess, avoiding API latency and behaving exactly like a human at the terminal.</li> </ol>"},{"location":"architecture/#competitive-comparison","title":"Competitive Comparison","text":"Feature DeterminAgent LangGraph/LangChain CrewAI AutoGen Cost $0 (CLI subs) Per-token API Per-token API Per-token API Provider Focus CLI tools Any API Any API Any API Orchestration Graph-based Graph-based Role-based Conversational"},{"location":"architecture/#3-system-design","title":"3. System Design","text":""},{"location":"architecture/#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Template Flows (flows/)                                   \u2502  \u2190 For non-programmers\n\u2502  - Pre-built Python workflow scripts                       \u2502     &amp; quick start\n\u2502  - Copy, customize, run                                    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Configuration Layer (Required for Flows)                  \u2502  \u2190 Required\n\u2502  - YAML agent settings &amp; prompts                            \u2502\n\u2502  - load_config() auto-discovery                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Core Library                                              \u2502  \u2190 Foundation\n\u2502  - UnifiedAgent, Adapters, SessionManager, Parsers         \u2502\n\u2502  - Full Python control with LangGraph                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#system-components","title":"System Components","text":""},{"location":"architecture/#unifiedagent-interface","title":"UnifiedAgent Interface","text":"<p>The main entry point for interaction. It abstracts the underlying CLI tools. <pre><code>class UnifiedAgent:\n    def send(self, prompt: str, max_retries: int = 2) -&gt; str: ...\n    def send_structured(self, prompt: str, schema: Type[BaseModel]) -&gt; BaseModel: ...\n    def get_history(self) -&gt; list[Message]: ...\n    def clear_session(self): ...\n</code></pre></p>"},{"location":"architecture/#sessionmanager","title":"SessionManager","text":"<p>Handles native session flags for all providers. It ensures that conversation history is maintained within the CLI tool's local context. - Claude: <code>--session-id &lt;uuid&gt;</code> for first call, <code>-r &lt;uuid&gt;</code> for resume. - Gemini: <code>--resume &lt;uuid&gt;</code> - Copilot: <code>--resume [sessionId]</code>, <code>--continue</code> - Codex: <code>exec</code> / <code>exec resume &lt;id&gt;</code></p>"},{"location":"architecture/#provider-adapters","title":"Provider Adapters","text":"<p>Specific implementations for each CLI tool. Each adapter handles command building, output parsing, and error normalization. - <code>build_command()</code>: Constructs the subprocess call. - <code>parse_output()</code>: Extracts the response from raw stdout. - <code>handle_error()</code>: Converts return codes and stderr into typed exceptions.</p>"},{"location":"architecture/#4-provider-capabilities","title":"4. Provider Capabilities","text":"Feature Claude Code Gemini CLI GitHub Copilot OpenAI Codex Session IDs \u2705 <code>--session-id</code>, <code>-r</code> \u2705 <code>--resume</code> \u2705 <code>--resume</code>, <code>--continue</code> \u2705 <code>exec resume</code> System Prompt \u2705 <code>--system-prompt</code> \u26a0\ufe0f Via subagents \u26a0\ufe0f Via <code>.agent.md</code> \u26a0\ufe0f Via <code>AGENTS.md</code> Output Format json/text/stream-json json/text/stream-json json/text JSON Lines Web Search <code>--allowedTools WebSearch</code> Built-in <code>--allow-all-tools</code>, <code>--allow-all-urls</code> config.toml Sandbox Mode \u274c No \u2705 Docker \u274c No \u2705 Built-in"},{"location":"architecture/#when-to-use-each-provider","title":"When to Use Each Provider","text":"Provider Best For Model Strength Claude Writing, planning, complex reasoning Most capable overall Copilot GitHub integration, PR workflows Fastest for code Gemini Research, analysis, web search Best free tier Codex Code execution, sandbox testing Best for automation"},{"location":"architecture/#5-decision-log-alternatives","title":"5. Decision Log &amp; Alternatives","text":""},{"location":"architecture/#session-management","title":"Session Management","text":"<ul> <li>Alternative: File-based (JSON) or SQLite store.</li> <li>Decision: Native sessions. Best performance, no additional storage overhead, and all 4 target CLIs now support it natively.</li> </ul>"},{"location":"architecture/#design-decisions","title":"Design Decisions","text":"<ul> <li>History Truncation: Default to last 5 messages for token efficiency in long flows.</li> <li>Codex Sandbox: Default to <code>workspace-write</code> for maximum utility in automation.</li> <li>Library vs Framework: Focus on Library-Only. YAML is used for agent settings (provider/model) but NOT for flow logic. Flow logic belongs in Python.</li> </ul>"},{"location":"architecture/#6-technical-reference","title":"6. Technical Reference","text":""},{"location":"architecture/#model-aliases","title":"Model Aliases","text":"Alias Claude Copilot Gemini Codex <code>fast</code> haiku claude-haiku-4.5 gemini-2.5-flash gpt-5.1-codex-mini <code>balanced</code> sonnet claude-sonnet-4-5 gemini-2.5-pro gpt-5.1 <code>powerful</code> opus gpt-5 gemini-2.5-pro gpt-5.1-codex-max <code>reasoning</code> opusplan gpt-5 gemini-2.5-pro o3 <code>free</code> haiku claude-haiku-4.5 gemini-2.5-flash gpt-5.1-codex-mini"},{"location":"architecture/#tool-permissions","title":"Tool Permissions","text":"<ul> <li>Claude: <code>[\"--allowedTools\", \"WebSearch,WebFetch\"]</code></li> <li>Gemini: Built-in.</li> <li>Copilot: <code>[\"--allow-all-tools\", \"--allow-all-urls\"]</code></li> <li>Codex: Via <code>config.toml</code>: <code>web_search_request = true</code>.</li> </ul>"},{"location":"architecture/#7-testing-risk-mitigation","title":"7. Testing &amp; Risk Mitigation","text":""},{"location":"architecture/#strategy","title":"Strategy","text":"<ul> <li>Unit Tests: Mock subprocess calls to verify command building and output parsing.</li> <li>Integration Tests: Run narrow, well-defined workflows against mock environments.</li> <li>Error Normalization: All adapters raise typed exceptions: <code>ProviderNotAvailable</code>, <code>RateLimitExceeded</code>, <code>ExecutionError</code>.</li> </ul>"},{"location":"architecture/#risk-mitigation","title":"Risk Mitigation","text":"<ul> <li>Output Parsing: Use multi-pattern regex (battle-tested) and Pydantic validation.</li> <li>Retries: Implement configurable retry logic with session resets for transient CLI failures.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to DeterminAgent will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Production readiness documentation (CHANGELOG, CONTRIBUTING, CODE_OF_CONDUCT, SECURITY)</li> <li>GitHub Issue and PR templates</li> <li>Enhanced README with installation instructions and troubleshooting</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved error handling in Blog Flow (uses exception type inspection instead of string matching)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Removed unused <code>filename_template</code> configuration option from Blog Flow</li> </ul>"},{"location":"changelog/#0100-2026-01-03","title":"0.10.0 - 2026-01-03","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Phase 6: Code Efficiency &amp; Utilities</li> <li><code>determinagent.ui</code> module for console formatting</li> <li><code>determinagent.utils</code> module for general utilities (<code>sanitize_filename</code>, <code>truncate_id</code>)</li> <li><code>determinagent.cli_utils</code> module for argparse helpers</li> <li>Phase 5: Additional Adapters</li> <li>Gemini CLI adapter with native session support</li> <li>OpenAI Codex adapter with sandbox mode</li> <li>Phase 4: Template Flows</li> <li><code>flows/blog/</code> directory with complete Writer \u2192 Editor \u2192 Reviewer workflow</li> <li>YAML configuration support for prompts and defaults</li> <li>Phase 3: Configuration Support</li> <li>Optional YAML configuration loading via <code>determinagent.config</code></li> <li>Prompt templates externalized to YAML</li> <li>Phase 2: Library Polish</li> <li>Pydantic-based type validation across all models</li> <li>Unified exception hierarchy (<code>DeterminAgentError</code> and subclasses)</li> <li>90%+ test coverage with strict type checking</li> <li>Phase 1: Core Library</li> <li><code>UnifiedAgent</code> for provider-agnostic AI interaction</li> <li><code>SessionManager</code> for conversation history management</li> <li>Provider adapters: Claude, Copilot, Gemini, Codex</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Migrated from <code>examples/</code> to <code>flows/</code> directory structure</li> <li>Removed legacy CLI framework in favor of library-only approach</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Global CLI entry point (replaced by template flows)</li> <li>Legacy framework components</li> </ul>"},{"location":"changelog/#010-2025-12-15","title":"0.1.0 - 2025-12-15","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Initial prototype with Claude and Copilot adapters</li> <li>Basic workflow orchestration using LangGraph</li> <li>Proof-of-concept blog generation workflow</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete command-line reference for all supported AI CLI tools.</p>"},{"location":"cli-reference/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Claude Code CLI</li> <li>Gemini CLI</li> <li>GitHub Copilot CLI</li> <li>OpenAI Codex CLI</li> <li>Configuration Priority</li> </ol>"},{"location":"cli-reference/#claude-code-cli","title":"Claude Code CLI","text":""},{"location":"cli-reference/#session-management","title":"Session Management","text":"Flag Format Purpose <code>-p</code> <code>claude -p \"query\"</code> Print/headless mode (non-interactive) <code>-c</code> / <code>--continue</code> <code>claude -c</code> Continue most recent conversation <code>-r</code> / <code>--resume</code> <code>claude -r \"session-id\"</code> Resume specific session by ID <code>--session-id</code> <code>claude --session-id \"uuid\"</code> Create/use specific session ID"},{"location":"cli-reference/#model-selection","title":"Model Selection","text":"Flag Format Purpose <code>--model</code> <code>claude --model &lt;alias&gt;</code> Specify model: <code>sonnet</code>, <code>opus</code>, <code>haiku</code>, <code>opusplan</code> <p>Available Models: <code>sonnet</code> (latest), <code>opus</code> (latest), <code>haiku</code>, <code>opusplan</code> (hybrid)</p>"},{"location":"cli-reference/#system-prompt","title":"System Prompt","text":"Flag Format Purpose <code>--system-prompt</code> <code>claude --system-prompt \"...\"</code> Override default instructions <code>--system-prompt-file</code> <code>claude --system-prompt-file /path</code> Load from file <code>--append-system-prompt</code> <code>claude --append-system-prompt \"...\"</code> Add to defaults"},{"location":"cli-reference/#tool-control","title":"Tool Control","text":"Flag Format Purpose <code>--allowedTools</code> <code>claude --allowedTools \"Read,Bash(git:*)\"</code> Allow only specified tools <code>--disallowedTools</code> <code>claude --disallowedTools \"Bash(rm:*)\"</code> Deny specific tools <p>Available Tools: <code>Read</code>, <code>Write</code>, <code>Bash</code>, <code>Grep</code>, <code>Glob</code>, <code>WebSearch</code>, <code>WebFetch</code></p>"},{"location":"cli-reference/#output-debug","title":"Output &amp; Debug","text":"Flag Format Purpose <code>--output-format</code> <code>claude -p --output-format json</code> Format: <code>text</code>, <code>json</code>, <code>stream-json</code> <code>--verbose</code> <code>claude --verbose</code> Enable verbose logging <code>--mcp-debug</code> <code>claude --mcp-debug</code> Debug MCP server connections"},{"location":"cli-reference/#examples","title":"Examples","text":"<pre><code># Headless with specific model and JSON output\nclaude -p \"analyze this\" --model opus --output-format json\n\n# Continue conversation with custom instructions\nclaude -c --append-system-prompt \"Focus on security\"\n\n# Use only safe tools\nclaude --allowedTools \"Read,Grep\" \"search the codebase\"\n\n# Resume with debugging\nclaude --continue --verbose \"next steps\"\n</code></pre>"},{"location":"cli-reference/#gemini-cli","title":"Gemini CLI","text":""},{"location":"cli-reference/#execution-prompts","title":"Execution &amp; Prompts","text":"Flag Format Purpose <code>-p</code> / <code>--prompt</code> <code>gemini -p \"query\"</code> Single prompt (non-interactive) <code>-i</code> / <code>--prompt-interactive</code> <code>gemini -i \"text\"</code> Start interactive with prompt"},{"location":"cli-reference/#model-selection_1","title":"Model Selection","text":"Flag Format Purpose <code>-m</code> / <code>--model</code> <code>gemini -m gemini-2.5-flash</code> Specify model <p>Available Models: <code>gemini-2.5-flash</code>, <code>gemini-2.5-pro</code></p>"},{"location":"cli-reference/#session-management_1","title":"Session Management","text":"Flag Format Purpose <code>--resume</code> <code>gemini --resume</code> Resume most recent session <code>--resume &lt;index&gt;</code> <code>gemini --resume 1</code> Resume by index <code>--resume &lt;uuid&gt;</code> <code>gemini --resume abc-123</code> Resume by UUID <code>--list-sessions</code> <code>gemini --list-sessions</code> List all sessions <code>--delete-session</code> <code>gemini --delete-session 2</code> Delete session"},{"location":"cli-reference/#safety-approval","title":"Safety &amp; Approval","text":"Flag Format Purpose <code>-s</code> / <code>--sandbox</code> <code>gemini --sandbox</code> Enable sandbox mode <code>--sandbox-image</code> <code>gemini --sandbox-image ubuntu:22.04</code> Custom Docker image <code>-y</code> / <code>--yolo</code> <code>gemini --yolo</code> Auto-approve all tool calls <code>--approval-mode</code> <code>gemini --approval-mode default</code> <code>default</code>, <code>auto_edit</code>, <code>yolo</code>"},{"location":"cli-reference/#output-formatting","title":"Output Formatting","text":"Flag Format Purpose <code>--output-format</code> <code>gemini --output-format json</code> <code>text</code>, <code>json</code>, <code>stream-json</code>"},{"location":"cli-reference/#model-parameters","title":"Model Parameters","text":"Flag Format Purpose <code>-t</code> / <code>--temperature</code> <code>gemini -t 0.5</code> Set temperature (0.0-2.0) <code>-b</code> / <code>--thinking-budget</code> <code>gemini -b 8192</code> Max thinking tokens"},{"location":"cli-reference/#examples_1","title":"Examples","text":"<pre><code># Headless with JSON output\ngemini -p \"analyze code\" --output-format json\n\n# Resume with auto-approval and streaming\ngemini --resume --yolo --output-format stream-json\n\n# Custom model and temperature\ngemini -m gemini-2.5-pro -t 0.3 -p \"complex task\"\n</code></pre>"},{"location":"cli-reference/#github-copilot-cli","title":"GitHub Copilot CLI","text":""},{"location":"cli-reference/#session-management_2","title":"Session Management","text":"Flag Format Purpose <code>--resume</code> <code>copilot --resume</code> Resume previous session <code>--resume &lt;id&gt;</code> <code>copilot --resume abc123</code> Resume by session ID <code>--continue</code> <code>copilot --continue</code> Resume most recent session"},{"location":"cli-reference/#execution-mode","title":"Execution Mode","text":"Flag Format Purpose <code>-p</code> / <code>--prompt</code> <code>copilot -p \"task\"</code> Programmatic (non-interactive) mode"},{"location":"cli-reference/#model-selection_2","title":"Model Selection","text":"Flag Format Purpose <code>--model</code> <code>copilot --model \"claude-sonnet-4\"</code> Specify model <p>Available Models: <code>claude-sonnet-4-5</code> (default), <code>claude-sonnet-4</code>, <code>gpt-5</code>, <code>claude-haiku-4.5</code></p>"},{"location":"cli-reference/#tool-approval","title":"Tool Approval","text":"Flag Format Purpose <code>--allow-all-tools</code> <code>copilot --allow-all-tools</code> Allow any tool <code>--allow-tool</code> <code>copilot --allow-tool 'shell(npm test:*)'</code> Allow specific tool <code>--deny-tool</code> <code>copilot --deny-tool 'shell(rm)'</code> Deny specific tool <code>--allow-all-urls</code> <code>copilot --allow-all-urls</code> Allow web requests"},{"location":"cli-reference/#output-format","title":"Output Format","text":"Flag Format Purpose <code>--format</code> <code>copilot --format json</code> <code>json</code> or <code>text</code>"},{"location":"cli-reference/#agent-selection","title":"Agent Selection","text":"Flag Format Purpose <code>--agent</code> <code>copilot --agent=refactor-agent</code> Use custom agent"},{"location":"cli-reference/#examples_2","title":"Examples","text":"<pre><code># Programmatic mode with tool control\ncopilot -p \"Run tests\" --allow-tool 'shell(npm test:*)'\n\n# Using custom agent\ncopilot --agent=refactor-agent -p \"Refactor this\"\n\n# Restrict dangerous operations\ncopilot --allow-all-tools --deny-tool 'shell(rm)' --deny-tool 'shell(sudo)'\n\n# JSON output for automation\ncopilot -p \"Fix bug\" --format json\n</code></pre>"},{"location":"cli-reference/#openai-codex-cli","title":"OpenAI Codex CLI","text":""},{"location":"cli-reference/#execution-modes","title":"Execution Modes","text":"Command Purpose <code>codex</code> Interactive TUI mode <code>codex \"prompt\"</code> Interactive with initial prompt <code>codex exec \"prompt\"</code> Non-interactive automation <code>codex exec resume &lt;id&gt;</code> Resume non-interactive session <code>codex resume</code> Resume picker for interactive <code>codex resume --last</code> Resume most recent session"},{"location":"cli-reference/#model-selection_3","title":"Model Selection","text":"Flag Format Purpose <code>-m</code> / <code>--model</code> <code>codex -m gpt-5.1</code> Specify model <p>Available Models: <code>gpt-5.1-codex-max</code> (default), <code>gpt-5.1</code>, <code>gpt-5.1-codex-mini</code>, <code>o3</code>, <code>o4-mini</code></p>"},{"location":"cli-reference/#approval-policies","title":"Approval Policies","text":"Flag Format Purpose <code>-a</code> / <code>--ask-for-approval</code> <code>codex -a untrusted</code> Set approval policy <code>--full-auto</code> <code>codex --full-auto</code> Auto-approve (on-failure + workspace-write) <p>Approval Values: <code>suggest</code>, <code>auto-edit</code>, <code>untrusted</code>, <code>on-failure</code>, <code>on-request</code>, <code>never</code></p>"},{"location":"cli-reference/#sandbox-modes","title":"Sandbox Modes","text":"Flag Format Purpose <code>--sandbox</code> <code>codex --sandbox read-only</code> Set sandbox mode <p>Sandbox Values: - <code>read-only</code> - Read files only (default for exec) - <code>workspace-write</code> - Allow writes to cwd and $TMPDIR - <code>danger-full-access</code> - No restrictions</p>"},{"location":"cli-reference/#output-debugging","title":"Output &amp; Debugging","text":"Flag Format Purpose <code>--json</code> <code>codex exec --json \"task\"</code> Stream JSON Lines output <code>-o</code> / <code>--output-last-message</code> <code>codex exec -o file.txt \"task\"</code> Write final output to file <code>--output-schema</code> <code>codex exec --output-schema schema.json</code> Structured JSON output <code>-d</code> / <code>--debug</code> <code>codex --debug</code> Enable debug logging"},{"location":"cli-reference/#directory-context","title":"Directory &amp; Context","text":"Flag Format Purpose <code>-C</code> / <code>--cd</code> <code>codex -C /path/to/project</code> Set working directory <code>--add-dir</code> <code>codex --add-dir ../backend</code> Add extra writable roots <code>-i</code> / <code>--image</code> <code>codex -i screenshot.png \"explain\"</code> Attach images"},{"location":"cli-reference/#mcp-server-management","title":"MCP Server Management","text":"Command Purpose <code>codex mcp add name -- command args</code> Add STDIO MCP server <code>codex mcp list</code> List configured servers <code>codex mcp get server-name</code> Show server config <code>codex mcp remove server-name</code> Remove MCP server"},{"location":"cli-reference/#examples_3","title":"Examples","text":"<pre><code># Non-interactive with full automation\ncodex exec --full-auto \"add unit tests for auth\"\n\n# Read-only analysis with JSON output\ncodex exec --json \"count lines of code\"\n\n# Full access for network operations\ncodex exec --sandbox danger-full-access \"fetch and summarize API docs\"\n\n# Resume and continue previous work\ncodex exec resume --last \"fix the remaining issues\"\n\n# Multi-directory project\ncodex --cd frontend --add-dir ../backend --add-dir ../shared\n\n# With specific model\ncodex -m o3 \"optimize this algorithm\"\n</code></pre>"},{"location":"cli-reference/#configuration-priority","title":"Configuration Priority","text":"<p>All four CLIs apply settings in this order (highest to lowest priority):</p> <ol> <li>Command-line arguments (always wins)</li> <li>Environment variables</li> <li>Project/local config (<code>./&lt;cli&gt;/settings.json</code>, <code>.github/</code>, <code>.codex/config.toml</code>)</li> <li>User config (<code>~/.claude/</code>, <code>~/.gemini/</code>, <code>~/.copilot/</code>, <code>~/.codex/</code>)</li> <li>System defaults</li> </ol> <p>Key Insight: Command-line flags override everything, making them ideal for orchestration scripts.</p>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"Provider Variable Purpose Claude <code>ANTHROPIC_MODEL</code> Default model Gemini <code>GEMINI_API_KEY</code> API authentication Gemini <code>GEMINI_MODEL</code> Default model Codex <code>OPENAI_API_KEY</code> API authentication (alternative to login) Codex <code>CODEX_HOME</code> Override config directory"},{"location":"cli-reference/#configuration-files","title":"Configuration Files","text":"Provider User Config Project Config Claude <code>~/.claude/settings.json</code> <code>.claude/settings.json</code> Gemini <code>~/.gemini/settings.json</code> <code>.gemini/settings.json</code> Copilot <code>~/.copilot/config</code> <code>.github/copilot-instructions.md</code> Codex <code>~/.codex/config.toml</code> <code>.codex/config.toml</code>, <code>AGENTS.md</code> <p>See official documentation for complete reference: - Claude Code CLI - Gemini CLI - GitHub Copilot CLI - OpenAI Codex CLI</p>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and unwelcome sexual attention or   advances</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained harassing behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No online or offline interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained harassing behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing to DeterminAgent","text":"<p>Thank you for your interest in contributing to DeterminAgent! This document provides guidelines and information for contributors.</p>"},{"location":"contributing/#table-of-contents","title":"\ud83d\udccb Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>Getting Started</li> <li>Development Setup</li> <li>Making Changes</li> <li>Pull Request Process</li> <li>Style Guide</li> <li>Testing Standards</li> <li>Reporting Issues</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project adheres to the Contributor Covenant Code of Conduct. By participating, you are expected to uphold this code. Please report unacceptable behavior to the maintainers.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+ (3.11 or 3.12 recommended)</li> <li>Git for version control</li> <li>At least one supported CLI tool installed:</li> <li>Claude Code (<code>claude</code>)</li> <li>GitHub Copilot CLI (<code>gh copilot</code>)</li> <li>Gemini CLI (<code>gemini</code>)</li> <li>OpenAI Codex (<code>codex</code>)</li> </ul>"},{"location":"contributing/#fork-and-clone","title":"Fork and Clone","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR_USERNAME/determinagent.git\ncd determinagent\n</code></pre></li> <li>Add the upstream remote:    <pre><code>git remote add upstream https://github.com/determinagent/determinagent.git\n</code></pre></li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#install-dependencies","title":"Install Dependencies","text":"<pre><code># Install package with development dependencies using Poetry\npoetry install\n\n# Optionally activate the Poetry shell\npoetry shell\n</code></pre>"},{"location":"contributing/#verify-setup","title":"Verify Setup","text":"<pre><code># Run all quality checks\nmake check\n\n# Or run individually:\nmake lint       # Linting with ruff\nmake typecheck  # Type checking with mypy\nmake test       # Unit tests with pytest\n</code></pre>"},{"location":"contributing/#making-changes","title":"Making Changes","text":""},{"location":"contributing/#branch-naming","title":"Branch Naming","text":"<p>Create a descriptive branch from <code>main</code>:</p> <pre><code>git checkout main\ngit pull upstream main\ngit checkout -b &lt;type&gt;/&lt;short-description&gt;\n</code></pre> <p>Branch types: - <code>feature/</code> - New functionality - <code>fix/</code> - Bug fixes - <code>docs/</code> - Documentation updates - <code>refactor/</code> - Code refactoring - <code>test/</code> - Test additions/improvements</p> <p>Examples: - <code>feature/openai-adapter</code> - <code>fix/session-timeout</code> - <code>docs/api-reference</code></p>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;description&gt;\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p> <p>Examples: <pre><code>feat(adapters): add support for Anthropic Claude API\nfix(sessions): handle timeout errors gracefully\ndocs(readme): add installation instructions\n</code></pre></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Update from upstream: <pre><code>git fetch upstream\ngit rebase upstream/main\n</code></pre></p> </li> <li> <p>Run all checks: <pre><code>make check\n</code></pre>    All checks must pass:</p> </li> <li>\u2705 Linting (ruff)</li> <li>\u2705 Type checking (mypy)</li> <li>\u2705 Unit tests (pytest)</li> <li> <p>\u2705 Coverage \u2265 70% per file</p> </li> <li> <p>Update documentation if needed</p> </li> </ol>"},{"location":"contributing/#submitting","title":"Submitting","text":"<ol> <li> <p>Push your branch:    <pre><code>git push origin &lt;branch-name&gt;\n</code></pre></p> </li> <li> <p>Open a Pull Request against <code>main</code></p> </li> <li> <p>Fill out the PR template completely</p> </li> <li> <p>Request review from maintainers</p> </li> </ol>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ul> <li>PRs require at least one maintainer approval</li> <li>Address all review comments</li> <li>Keep the PR focused (one feature/fix per PR)</li> <li>Squash commits if requested</li> </ul>"},{"location":"contributing/#style-guide","title":"Style Guide","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<p>We use Ruff for linting and Black for formatting:</p> <pre><code># Auto-fix linting issues\nmake lint-fix\n\n# Check formatting\nruff format --check determinagent/ flows/ tests/\n</code></pre> <p>Key conventions: - Line length: 100 characters - Use type hints for all function signatures - Use docstrings for all public APIs (Google style) - Prefer f-strings over <code>.format()</code> or <code>%</code></p>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<pre><code>def send(self, prompt: str, allow_web: bool = False) -&gt; str:\n    \"\"\"\n    Send a prompt to the AI provider and return the response.\n\n    Args:\n        prompt: The user prompt to send.\n        allow_web: Whether to allow web search for context.\n\n    Returns:\n        The AI-generated response text.\n\n    Raises:\n        ProviderNotAvailable: If the CLI tool is not installed.\n        ProviderError: If the provider returns an error.\n    \"\"\"\n</code></pre>"},{"location":"contributing/#testing-standards","title":"Testing Standards","text":""},{"location":"contributing/#test-structure","title":"Test Structure","text":"<p>We follow the ZOMBIES testing approach and AAA (Arrange-Act-Assert) pattern:</p> <pre><code>def test_send_prompt_valid_input_returns_response():\n    \"\"\"Test that send() returns a response for valid input.\"\"\"\n    # Arrange\n    agent = UnifiedAgent(provider=\"claude\", model=\"balanced\")\n    prompt = \"Hello, world!\"\n\n    # Act\n    with patch.object(agent, '_execute_cli', return_value=\"Hi there!\"):\n        result = agent.send(prompt)\n\n    # Assert\n    assert result == \"Hi there!\"\n</code></pre>"},{"location":"contributing/#naming-convention","title":"Naming Convention","text":"<pre><code>test_&lt;function_name&gt;_&lt;scenario&gt;_&lt;expected_result&gt;\n</code></pre> <p>Examples: - <code>test_send_empty_prompt_raises_validation_error</code> - <code>test_parse_review_valid_format_returns_scores</code> - <code>test_session_expired_creates_new_session</code></p>"},{"location":"contributing/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Minimum 70% coverage per file</li> <li>Run with coverage report:   <pre><code>make test-cov\n</code></pre></li> </ul>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<p>Use the Bug Report issue template and include: - Python version and OS - Steps to reproduce - Expected vs actual behavior - Error messages and tracebacks - Relevant configuration</p>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>Use the Feature Request issue template and include: - Use case description - Proposed solution - Alternative approaches considered</p>"},{"location":"contributing/#security-issues","title":"Security Issues","text":"<p>Do not open public issues for security vulnerabilities. See SECURITY.md for responsible disclosure.</p>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Check existing Issues</li> <li>Open a Discussion</li> <li>Read the Architecture documentation</li> </ul> <p>Thank you for contributing! \ud83c\udf89</p>"},{"location":"roadmap/","title":"DeterminAgent Actionable Plan &amp; Roadmap","text":"<p>Version: 4.0 Approach: Library-Only with Template Flows Status: Pre-Production Polish &amp; Release Prep</p>"},{"location":"roadmap/#phase-7-production-readiness-current-focus","title":"\ud83d\ude80 Phase 7: Production Readiness (Current Focus)","text":"<p>Goal: Bridge the gap between \"working code\" and \"publishable open-source project\" by adding community assets, documentation, and polished metadata.</p>"},{"location":"roadmap/#71-community-oss-essentials-high-priority","title":"7.1 Community &amp; OSS Essentials (High Priority)","text":"<ul> <li>[ ] Create <code>CHANGELOG.md</code>: Document versions and changes.</li> <li>[ ] Create <code>CONTRIBUTING.md</code>: Guide for issues, PRs, and style expectations.</li> <li>[ ] Create <code>CODE_OF_CONDUCT.md</code>: Standard community standards.</li> <li>[ ] Create <code>SECURITY.md</code>: Document prompt injection risks and subprocess security model.</li> <li>[ ] Create Issue/PR Templates: Standardize contributions.</li> </ul>"},{"location":"roadmap/#72-documentation-polish","title":"7.2 Documentation Polish","text":"<ul> <li>[ ] Enhance <code>README.md</code>:</li> <li>Add installation instructions (<code>pip install</code>).</li> <li>Add \"Quick Start\" demo GIF or screenshot.</li> <li>Add Prerequisites (Python version, CLI tools).</li> <li>Add Compatibility Matrix (Providers vs Features).</li> <li>Add Troubleshooting section.</li> <li>[ ] Generate API Documentation: Setup <code>mkdocs material</code> for auto-generated reference.</li> <li>[ ] Badges: Add PyPI, License, and Status badges to README.</li> </ul>"},{"location":"roadmap/#73-metadata-packaging","title":"7.3 Metadata &amp; Packaging","text":"<ul> <li>[ ] Update <code>pyproject.toml</code>: Add author email, verify repo URLs.</li> <li>[ ] Update <code>LICENSE</code>: Add copyright year to appendix.</li> <li>[ ] Clean Repository: Remove <code>backup.sql</code> or add to <code>.gitignore</code>.</li> </ul>"},{"location":"roadmap/#74-final-code-refinements","title":"7.4 Final Code Refinements","text":"<ul> <li>[ ] Fix <code>flows/blog/main.py</code>: Robustify error handling (remove fragile string matching).</li> <li>[ ] Fix <code>flows/blog/main.yaml</code>: Implement or remove unused <code>filename_template</code>.</li> <li>[ ] Security Review: Audit <code>subprocess.run</code> calls for prompt injection safety.</li> </ul>"},{"location":"roadmap/#future-roadmap-post-v10","title":"\ud83d\udd2e Future Roadmap (Post-v1.0)","text":""},{"location":"roadmap/#phase-8-robustness-expansion","title":"Phase 8: Robustness &amp; Expansion","text":"<ul> <li>[ ] Integration Test Suite: Framework for testing with real (mocked) CLI binaries.</li> <li>[ ] Jupyter Notebooks: Interactive tutorials for library usage.</li> <li>[ ] Docker Support: Containerized environment for safely running <code>codex</code> and others.</li> <li>[ ] CI/CD: GitHub Actions workflow for automated testing and publishing.</li> </ul>"},{"location":"roadmap/#history-resume","title":"\ud83d\udcdc History (Resume)","text":""},{"location":"roadmap/#phase-6-code-efficiency-utilities","title":"\u2705 Phase 6: Code Efficiency &amp; Utilities","text":"<p>Extracted boilerplate from flows into the library, added UI formatting utilties, and refactored the Blog Flow.</p>"},{"location":"roadmap/#phase-5-additional-adapters","title":"\u2705 Phase 5: Additional Adapters","text":"<p>Implemented Gemini and OpenAI Codex adapters with native session support and sandbox modes.</p>"},{"location":"roadmap/#phase-4-template-flows","title":"\u2705 Phase 4: Template Flows","text":"<p>Migrated from <code>examples/</code> to <code>flows/</code> directory structure, standardized the Blog Flow template.</p>"},{"location":"roadmap/#phase-3-configuration-support","title":"\u2705 Phase 3: Configuration Support","text":"<p>Added optional YAML configuration for agent defaults and removed legacy framework/CLI code.</p>"},{"location":"roadmap/#phase-2-library-polish","title":"\u2705 Phase 2: Library Polish","text":"<p>Achieved strict type safety (Pydantic), 90%+ test coverage, and unified exception handling.</p>"},{"location":"roadmap/#phase-1-core-library-base","title":"\u2705 Phase 1: Core Library (Base)","text":"<p>Extracted provider adapters, <code>UnifiedAgent</code>, and <code>SessionManager</code> from the original prototype.</p> <p>Last updated: 2026-01-04</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#responsible-disclosure","title":"Responsible Disclosure","text":"<p>If you discover a security vulnerability in DeterminAgent, please do not open a public issue. Instead, please report it privately to [INSERT EMAIL ADDRESS].</p> <p>We will acknowledge your report within 48 hours and provide a timeline for addressing the issue.</p>"},{"location":"security/#security-model-risks","title":"Security Model &amp; Risks","text":"<p>DeterminAgent is a library that orchestrates AI CLI tools via subprocesses. This architecture introduces specific security considerations.</p>"},{"location":"security/#1-subprocess-execution","title":"1. Subprocess Execution","text":"<p>The library calls external binaries (e.g., <code>claude</code>, <code>gh</code>, <code>gemini</code>).  - Risk: If a provider name or command argument is maliciously constructed, it could lead to arbitrary command execution. - Mitigation: We use <code>subprocess.run</code> with list-based arguments instead of shell strings where possible. We validate provider names against a whitelist of supported adapters.</p>"},{"location":"security/#2-prompt-injection","title":"2. Prompt Injection","text":"<p>As with any LLM-based system, DeterminAgent is susceptible to prompt injection. - Risk: An untrusted input (e.g., a blog topic or user feedback) could contain instructions that trick the underlying AI model into ignoring its system prompt or performing unintended actions. - Mitigation: We provide structured system prompts and use LangGraph to enforce a deterministic state machine. However, the library currently treats the output of providers as untrusted data.</p>"},{"location":"security/#3-local-environment-security","title":"3. Local Environment Security","text":"<p>DeterminAgent relies on the security of the local environment and the installed CLI tools. - Risk: Malicious CLI tools or compromised local sessions could expose sensitive data. - Mitigation: Users should only use DeterminAgent with trusted CLI tools and within secure environments.</p>"},{"location":"security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>When reporting a vulnerability, please include: - A description of the issue. - A proof-of-concept or steps to reproduce. - Potential impact. - Any suggested remediations.</p>"},{"location":"security/#supported-versions","title":"Supported Versions","text":"<p>Currently, we only provide security updates for the latest stable release.</p> Version Supported 0.10.x :white_check_mark: &lt; 0.10.0 :x:"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed documentation for the DeterminAgent library modules.</p> <ul> <li>UnifiedAgent: The core orchestration class.</li> <li>Adapters: Provider-specific CLI wrappers.</li> <li>Sessions: Conversation history and session management.</li> <li>Exceptions: Standard error hierarchy.</li> </ul>"},{"location":"api/adapters/","title":"Adapters","text":""},{"location":"api/adapters/#base-adapter","title":"Base Adapter","text":""},{"location":"api/adapters/#determinagent.adapters.base.BaseAdapter","title":"<code>determinagent.adapters.base.BaseAdapter</code>","text":"<p>               Bases: <code>ProviderAdapter</code></p> <p>Alias for ProviderAdapter to maintain backward compatibility.</p> <p>The documentation generation expects a class named <code>BaseAdapter</code>. This subclass does not add any new behavior; it simply inherits all functionality from <code>ProviderAdapter</code>.</p> Source code in <code>determinagent/adapters/base.py</code> <pre><code>class BaseAdapter(ProviderAdapter):\n    \"\"\"Alias for ProviderAdapter to maintain backward compatibility.\n\n    The documentation generation expects a class named ``BaseAdapter``.\n    This subclass does not add any new behavior; it simply inherits all\n    functionality from ``ProviderAdapter``.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/adapters/#claude-adapter","title":"Claude Adapter","text":""},{"location":"api/adapters/#determinagent.adapters.claude.ClaudeAdapter","title":"<code>determinagent.adapters.claude.ClaudeAdapter</code>","text":"<p>               Bases: <code>ProviderAdapter</code></p> <p>Adapter for Claude Code CLI.</p> <p>Supports: - Session management via --session-id and -r flags - Model selection via --model flag - Web search via --allowedTools WebSearch,WebFetch - Custom tool permissions</p> Example <pre><code>adapter = ClaudeAdapter()\ncmd = adapter.build_command(\n    prompt=\"Write a haiku\",\n    model=\"sonnet\",\n    session_flags=[\"--session-id\", \"abc-123\"],\n)\n# Returns: [\"claude\", \"--model\", \"sonnet\", \"--session-id\", \"abc-123\", \"-p\", \"Write a haiku\"]\n</code></pre> Source code in <code>determinagent/adapters/claude.py</code> <pre><code>class ClaudeAdapter(ProviderAdapter):\n    \"\"\"\n    Adapter for Claude Code CLI.\n\n    Supports:\n    - Session management via --session-id and -r flags\n    - Model selection via --model flag\n    - Web search via --allowedTools WebSearch,WebFetch\n    - Custom tool permissions\n\n    Example:\n        ```python\n        adapter = ClaudeAdapter()\n        cmd = adapter.build_command(\n            prompt=\"Write a haiku\",\n            model=\"sonnet\",\n            session_flags=[\"--session-id\", \"abc-123\"],\n        )\n        # Returns: [\"claude\", \"--model\", \"sonnet\", \"--session-id\", \"abc-123\", \"-p\", \"Write a haiku\"]\n        ```\n    \"\"\"\n\n    provider_name: str = \"claude\"\n\n    def build_command(\n        self,\n        prompt: str,\n        model: str,\n        session_flags: list[str],\n        allow_web: bool = False,\n        tools: list[str] | None = None,\n        sandbox: str | None = None,  # Unused for Claude\n    ) -&gt; list[str]:\n        \"\"\"\n        Build Claude CLI command.\n\n        Args:\n            prompt: The prompt to send to Claude.\n            model: Model name (e.g., \"haiku\", \"sonnet\", \"opus\").\n            session_flags: Session management flags (--session-id or -r).\n            allow_web: Enable WebSearch and WebFetch tools.\n            tools: Additional tools to allow.\n            sandbox: Unused (Claude doesn't support sandbox mode).\n\n        Returns:\n            Command array for subprocess execution.\n\n        Examples:\n            First call:  [\"claude\", \"-p\", \"prompt\", \"--session-id\", \"uuid\"]\n            Resume:      [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\"]\n            With web:    [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\",\n                          \"--allowedTools\", \"WebSearch,WebFetch\"]\n        \"\"\"\n        cmd = [\"claude\"]\n\n        # Add model if specified (put flags before prompt)\n        if model:\n            cmd.extend([\"--model\", model])\n\n        # Add session flags (--session-id or -r)\n        cmd.extend(session_flags)\n\n        # Add prompt\n        cmd.extend([\"-p\", prompt])\n\n        # Build allowed tools list\n        allowed_tools: list[str] = []\n        if allow_web:\n            allowed_tools.extend([\"WebSearch\", \"WebFetch\"])\n        if tools:\n            allowed_tools.extend(tools)\n\n        if allowed_tools:\n            cmd.extend([\"--allowedTools\", \",\".join(allowed_tools)])\n\n        return cmd\n\n    def parse_output(self, raw_output: str) -&gt; str:\n        \"\"\"\n        Parse Claude output.\n\n        Claude outputs plain text, so we just strip whitespace.\n\n        Args:\n            raw_output: Raw stdout from Claude CLI.\n\n        Returns:\n            Cleaned response text.\n        \"\"\"\n        return raw_output.strip()\n\n    def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n        \"\"\"\n        Map Claude CLI errors to typed exceptions.\n\n        Args:\n            returncode: Process exit code.\n            stderr: Standard error output.\n\n        Returns:\n            Appropriate exception type based on error content.\n        \"\"\"\n        err_lower = stderr.lower()\n\n        if \"command not found\" in err_lower or \"not found\" in err_lower:\n            return ProviderNotAvailable(\n                \"Claude CLI not installed. Install with: npm install -g @anthropic-ai/claude-cli\",\n                provider=self.provider_name,\n            )\n        elif \"rate limit\" in err_lower or \"too many requests\" in err_lower:\n            return RateLimitExceeded(\n                \"Claude rate limit exceeded. Please wait before retrying.\",\n                provider=self.provider_name,\n            )\n        elif \"api key\" in err_lower or \"unauthorized\" in err_lower or \"auth\" in err_lower:\n            return ProviderAuthError(\n                \"Claude authentication failed. Check your API key configuration.\",\n                provider=self.provider_name,\n            )\n        elif \"invalid model\" in err_lower:\n            return ExecutionError(\n                f\"Invalid model specified: {stderr}\",\n                provider=self.provider_name,\n                returncode=returncode,\n                stderr=stderr,\n            )\n        else:\n            return ExecutionError(\n                f\"Claude CLI error (code {returncode}): {stderr}\",\n                provider=self.provider_name,\n                returncode=returncode,\n                stderr=stderr,\n            )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.claude.ClaudeAdapter.build_command","title":"<code>build_command(prompt, model, session_flags, allow_web=False, tools=None, sandbox=None)</code>","text":"<p>Build Claude CLI command.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to Claude.</p> required <code>model</code> <code>str</code> <p>Model name (e.g., \"haiku\", \"sonnet\", \"opus\").</p> required <code>session_flags</code> <code>list[str]</code> <p>Session management flags (--session-id or -r).</p> required <code>allow_web</code> <code>bool</code> <p>Enable WebSearch and WebFetch tools.</p> <code>False</code> <code>tools</code> <code>list[str] | None</code> <p>Additional tools to allow.</p> <code>None</code> <code>sandbox</code> <code>str | None</code> <p>Unused (Claude doesn't support sandbox mode).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Command array for subprocess execution.</p> <p>Examples:</p> <p>First call:  [\"claude\", \"-p\", \"prompt\", \"--session-id\", \"uuid\"] Resume:      [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\"] With web:    [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\",               \"--allowedTools\", \"WebSearch,WebFetch\"]</p> Source code in <code>determinagent/adapters/claude.py</code> <pre><code>def build_command(\n    self,\n    prompt: str,\n    model: str,\n    session_flags: list[str],\n    allow_web: bool = False,\n    tools: list[str] | None = None,\n    sandbox: str | None = None,  # Unused for Claude\n) -&gt; list[str]:\n    \"\"\"\n    Build Claude CLI command.\n\n    Args:\n        prompt: The prompt to send to Claude.\n        model: Model name (e.g., \"haiku\", \"sonnet\", \"opus\").\n        session_flags: Session management flags (--session-id or -r).\n        allow_web: Enable WebSearch and WebFetch tools.\n        tools: Additional tools to allow.\n        sandbox: Unused (Claude doesn't support sandbox mode).\n\n    Returns:\n        Command array for subprocess execution.\n\n    Examples:\n        First call:  [\"claude\", \"-p\", \"prompt\", \"--session-id\", \"uuid\"]\n        Resume:      [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\"]\n        With web:    [\"claude\", \"-p\", \"prompt\", \"-r\", \"uuid\",\n                      \"--allowedTools\", \"WebSearch,WebFetch\"]\n    \"\"\"\n    cmd = [\"claude\"]\n\n    # Add model if specified (put flags before prompt)\n    if model:\n        cmd.extend([\"--model\", model])\n\n    # Add session flags (--session-id or -r)\n    cmd.extend(session_flags)\n\n    # Add prompt\n    cmd.extend([\"-p\", prompt])\n\n    # Build allowed tools list\n    allowed_tools: list[str] = []\n    if allow_web:\n        allowed_tools.extend([\"WebSearch\", \"WebFetch\"])\n    if tools:\n        allowed_tools.extend(tools)\n\n    if allowed_tools:\n        cmd.extend([\"--allowedTools\", \",\".join(allowed_tools)])\n\n    return cmd\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.claude.ClaudeAdapter.handle_error","title":"<code>handle_error(returncode, stderr)</code>","text":"<p>Map Claude CLI errors to typed exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>returncode</code> <code>int</code> <p>Process exit code.</p> required <code>stderr</code> <code>str</code> <p>Standard error output.</p> required <p>Returns:</p> Type Description <code>Exception</code> <p>Appropriate exception type based on error content.</p> Source code in <code>determinagent/adapters/claude.py</code> <pre><code>def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n    \"\"\"\n    Map Claude CLI errors to typed exceptions.\n\n    Args:\n        returncode: Process exit code.\n        stderr: Standard error output.\n\n    Returns:\n        Appropriate exception type based on error content.\n    \"\"\"\n    err_lower = stderr.lower()\n\n    if \"command not found\" in err_lower or \"not found\" in err_lower:\n        return ProviderNotAvailable(\n            \"Claude CLI not installed. Install with: npm install -g @anthropic-ai/claude-cli\",\n            provider=self.provider_name,\n        )\n    elif \"rate limit\" in err_lower or \"too many requests\" in err_lower:\n        return RateLimitExceeded(\n            \"Claude rate limit exceeded. Please wait before retrying.\",\n            provider=self.provider_name,\n        )\n    elif \"api key\" in err_lower or \"unauthorized\" in err_lower or \"auth\" in err_lower:\n        return ProviderAuthError(\n            \"Claude authentication failed. Check your API key configuration.\",\n            provider=self.provider_name,\n        )\n    elif \"invalid model\" in err_lower:\n        return ExecutionError(\n            f\"Invalid model specified: {stderr}\",\n            provider=self.provider_name,\n            returncode=returncode,\n            stderr=stderr,\n        )\n    else:\n        return ExecutionError(\n            f\"Claude CLI error (code {returncode}): {stderr}\",\n            provider=self.provider_name,\n            returncode=returncode,\n            stderr=stderr,\n        )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.claude.ClaudeAdapter.parse_output","title":"<code>parse_output(raw_output)</code>","text":"<p>Parse Claude output.</p> <p>Claude outputs plain text, so we just strip whitespace.</p> <p>Parameters:</p> Name Type Description Default <code>raw_output</code> <code>str</code> <p>Raw stdout from Claude CLI.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Cleaned response text.</p> Source code in <code>determinagent/adapters/claude.py</code> <pre><code>def parse_output(self, raw_output: str) -&gt; str:\n    \"\"\"\n    Parse Claude output.\n\n    Claude outputs plain text, so we just strip whitespace.\n\n    Args:\n        raw_output: Raw stdout from Claude CLI.\n\n    Returns:\n        Cleaned response text.\n    \"\"\"\n    return raw_output.strip()\n</code></pre>"},{"location":"api/adapters/#copilot-adapter","title":"Copilot Adapter","text":""},{"location":"api/adapters/#determinagent.adapters.copilot.CopilotAdapter","title":"<code>determinagent.adapters.copilot.CopilotAdapter</code>","text":"<p>               Bases: <code>ProviderAdapter</code></p> <p>Adapter for GitHub Copilot CLI.</p> <p>Supports: - Session management via --resume flag - Model selection via --model flag - Tool access via --allow-all-tools and --allow-all-urls</p> <p>Note: Copilot uses different model naming conventions than Claude. This adapter provides a mapping for convenient aliasing.</p> Example <pre><code>adapter = CopilotAdapter()\ncmd = adapter.build_command(\n    prompt=\"Explain this code\",\n    model=\"balanced\",\n    session_flags=[\"--resume\", \"session-id\"],\n)\n</code></pre> Source code in <code>determinagent/adapters/copilot.py</code> <pre><code>class CopilotAdapter(ProviderAdapter):\n    \"\"\"\n    Adapter for GitHub Copilot CLI.\n\n    Supports:\n    - Session management via --resume flag\n    - Model selection via --model flag\n    - Tool access via --allow-all-tools and --allow-all-urls\n\n    Note: Copilot uses different model naming conventions than Claude.\n    This adapter provides a mapping for convenient aliasing.\n\n    Example:\n        ```python\n        adapter = CopilotAdapter()\n        cmd = adapter.build_command(\n            prompt=\"Explain this code\",\n            model=\"balanced\",\n            session_flags=[\"--resume\", \"session-id\"],\n        )\n        ```\n    \"\"\"\n\n    provider_name: str = \"copilot\"\n\n    # Copilot-specific model name mappings\n    MODEL_MAPPING: dict[str, str] = {\n        \"haiku\": \"claude-haiku-4.5\",\n        \"sonnet\": \"claude-sonnet-4-5\",\n        \"opus\": \"claude-sonnet-4\",  # No direct Opus equivalent in Copilot\n        \"fast\": \"claude-haiku-4.5\",\n        \"balanced\": \"claude-sonnet-4-5\",\n        \"powerful\": \"gpt-5\",\n    }\n\n    def build_command(\n        self,\n        prompt: str,\n        model: str,\n        session_flags: list[str],\n        allow_web: bool = False,\n        tools: list[str] | None = None,\n        sandbox: str | None = None,  # Unused for Copilot\n    ) -&gt; list[str]:\n        \"\"\"\n        Build Copilot CLI command.\n\n        Args:\n            prompt: The prompt to send to Copilot.\n            model: Model name or alias (will be mapped to Copilot model names).\n            session_flags: Session management flags (--resume or empty).\n            allow_web: Enable web access via --allow-all-urls.\n            tools: Additional tools (Copilot uses --allow-all-tools).\n            sandbox: Unused (Copilot doesn't support sandbox mode).\n\n        Returns:\n            Command array for subprocess execution.\n\n        Examples:\n            First call:  [\"copilot\", \"-p\", \"prompt\"]\n            Resume:      [\"copilot\", \"-p\", \"prompt\", \"--resume\", \"uuid\"]\n            With web:    [\"copilot\", \"-p\", \"prompt\", \"--allow-all-tools\", \"--allow-all-urls\"]\n        \"\"\"\n        cmd = [\"copilot\", \"-p\", prompt]\n\n        # Add session flags\n        cmd.extend(session_flags)\n\n        # Map model name to Copilot-specific name\n        copilot_model = self.MODEL_MAPPING.get(model, model)\n        if copilot_model:\n            cmd.extend([\"--model\", copilot_model])\n\n        # Copilot uses --allow-all-tools for extended access\n        if allow_web or tools:\n            cmd.append(\"--allow-all-tools\")\n            if allow_web:\n                cmd.append(\"--allow-all-urls\")\n\n        return cmd\n\n    def parse_output(self, raw_output: str) -&gt; str:\n        \"\"\"\n        Parse Copilot output.\n\n        Copilot outputs plain text, so we just strip whitespace.\n\n        Args:\n            raw_output: Raw stdout from Copilot CLI.\n\n        Returns:\n            Cleaned response text.\n        \"\"\"\n        return raw_output.strip()\n\n    def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n        \"\"\"\n        Map Copilot CLI errors to typed exceptions.\n\n        Args:\n            returncode: Process exit code.\n            stderr: Standard error output.\n\n        Returns:\n            Appropriate exception type based on error content.\n        \"\"\"\n        err_lower = stderr.lower()\n\n        if \"command not found\" in err_lower or \"not found\" in err_lower:\n            return ProviderNotAvailable(\n                \"Copilot CLI not installed. Install with: gh extension install github/copilot-cli\",\n                provider=self.provider_name,\n            )\n        elif \"rate limit\" in err_lower or \"too many requests\" in err_lower:\n            return RateLimitExceeded(\n                \"Copilot rate limit exceeded. Please wait before retrying.\",\n                provider=self.provider_name,\n            )\n        elif (\n            \"auth\" in err_lower\n            or \"login\" in err_lower\n            or \"unauthorized\" in err_lower\n            or \"not logged in\" in err_lower\n        ):\n            return ProviderAuthError(\n                \"Copilot authentication failed. Run 'gh auth login' to authenticate.\",\n                provider=self.provider_name,\n            )\n        elif \"github copilot\" in err_lower and \"access\" in err_lower:\n            return ProviderAuthError(\n                \"GitHub Copilot access required. Ensure you have an active Copilot subscription.\",\n                provider=self.provider_name,\n            )\n        else:\n            return ExecutionError(\n                f\"Copilot CLI error (code {returncode}): {stderr}\",\n                provider=self.provider_name,\n                returncode=returncode,\n                stderr=stderr,\n            )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.copilot.CopilotAdapter.build_command","title":"<code>build_command(prompt, model, session_flags, allow_web=False, tools=None, sandbox=None)</code>","text":"<p>Build Copilot CLI command.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to Copilot.</p> required <code>model</code> <code>str</code> <p>Model name or alias (will be mapped to Copilot model names).</p> required <code>session_flags</code> <code>list[str]</code> <p>Session management flags (--resume or empty).</p> required <code>allow_web</code> <code>bool</code> <p>Enable web access via --allow-all-urls.</p> <code>False</code> <code>tools</code> <code>list[str] | None</code> <p>Additional tools (Copilot uses --allow-all-tools).</p> <code>None</code> <code>sandbox</code> <code>str | None</code> <p>Unused (Copilot doesn't support sandbox mode).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Command array for subprocess execution.</p> <p>Examples:</p> <p>First call:  [\"copilot\", \"-p\", \"prompt\"] Resume:      [\"copilot\", \"-p\", \"prompt\", \"--resume\", \"uuid\"] With web:    [\"copilot\", \"-p\", \"prompt\", \"--allow-all-tools\", \"--allow-all-urls\"]</p> Source code in <code>determinagent/adapters/copilot.py</code> <pre><code>def build_command(\n    self,\n    prompt: str,\n    model: str,\n    session_flags: list[str],\n    allow_web: bool = False,\n    tools: list[str] | None = None,\n    sandbox: str | None = None,  # Unused for Copilot\n) -&gt; list[str]:\n    \"\"\"\n    Build Copilot CLI command.\n\n    Args:\n        prompt: The prompt to send to Copilot.\n        model: Model name or alias (will be mapped to Copilot model names).\n        session_flags: Session management flags (--resume or empty).\n        allow_web: Enable web access via --allow-all-urls.\n        tools: Additional tools (Copilot uses --allow-all-tools).\n        sandbox: Unused (Copilot doesn't support sandbox mode).\n\n    Returns:\n        Command array for subprocess execution.\n\n    Examples:\n        First call:  [\"copilot\", \"-p\", \"prompt\"]\n        Resume:      [\"copilot\", \"-p\", \"prompt\", \"--resume\", \"uuid\"]\n        With web:    [\"copilot\", \"-p\", \"prompt\", \"--allow-all-tools\", \"--allow-all-urls\"]\n    \"\"\"\n    cmd = [\"copilot\", \"-p\", prompt]\n\n    # Add session flags\n    cmd.extend(session_flags)\n\n    # Map model name to Copilot-specific name\n    copilot_model = self.MODEL_MAPPING.get(model, model)\n    if copilot_model:\n        cmd.extend([\"--model\", copilot_model])\n\n    # Copilot uses --allow-all-tools for extended access\n    if allow_web or tools:\n        cmd.append(\"--allow-all-tools\")\n        if allow_web:\n            cmd.append(\"--allow-all-urls\")\n\n    return cmd\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.copilot.CopilotAdapter.handle_error","title":"<code>handle_error(returncode, stderr)</code>","text":"<p>Map Copilot CLI errors to typed exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>returncode</code> <code>int</code> <p>Process exit code.</p> required <code>stderr</code> <code>str</code> <p>Standard error output.</p> required <p>Returns:</p> Type Description <code>Exception</code> <p>Appropriate exception type based on error content.</p> Source code in <code>determinagent/adapters/copilot.py</code> <pre><code>def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n    \"\"\"\n    Map Copilot CLI errors to typed exceptions.\n\n    Args:\n        returncode: Process exit code.\n        stderr: Standard error output.\n\n    Returns:\n        Appropriate exception type based on error content.\n    \"\"\"\n    err_lower = stderr.lower()\n\n    if \"command not found\" in err_lower or \"not found\" in err_lower:\n        return ProviderNotAvailable(\n            \"Copilot CLI not installed. Install with: gh extension install github/copilot-cli\",\n            provider=self.provider_name,\n        )\n    elif \"rate limit\" in err_lower or \"too many requests\" in err_lower:\n        return RateLimitExceeded(\n            \"Copilot rate limit exceeded. Please wait before retrying.\",\n            provider=self.provider_name,\n        )\n    elif (\n        \"auth\" in err_lower\n        or \"login\" in err_lower\n        or \"unauthorized\" in err_lower\n        or \"not logged in\" in err_lower\n    ):\n        return ProviderAuthError(\n            \"Copilot authentication failed. Run 'gh auth login' to authenticate.\",\n            provider=self.provider_name,\n        )\n    elif \"github copilot\" in err_lower and \"access\" in err_lower:\n        return ProviderAuthError(\n            \"GitHub Copilot access required. Ensure you have an active Copilot subscription.\",\n            provider=self.provider_name,\n        )\n    else:\n        return ExecutionError(\n            f\"Copilot CLI error (code {returncode}): {stderr}\",\n            provider=self.provider_name,\n            returncode=returncode,\n            stderr=stderr,\n        )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.copilot.CopilotAdapter.parse_output","title":"<code>parse_output(raw_output)</code>","text":"<p>Parse Copilot output.</p> <p>Copilot outputs plain text, so we just strip whitespace.</p> <p>Parameters:</p> Name Type Description Default <code>raw_output</code> <code>str</code> <p>Raw stdout from Copilot CLI.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Cleaned response text.</p> Source code in <code>determinagent/adapters/copilot.py</code> <pre><code>def parse_output(self, raw_output: str) -&gt; str:\n    \"\"\"\n    Parse Copilot output.\n\n    Copilot outputs plain text, so we just strip whitespace.\n\n    Args:\n        raw_output: Raw stdout from Copilot CLI.\n\n    Returns:\n        Cleaned response text.\n    \"\"\"\n    return raw_output.strip()\n</code></pre>"},{"location":"api/adapters/#gemini-adapter","title":"Gemini Adapter","text":""},{"location":"api/adapters/#determinagent.adapters.gemini.GeminiAdapter","title":"<code>determinagent.adapters.gemini.GeminiAdapter</code>","text":"<p>               Bases: <code>ProviderAdapter</code></p> <p>Adapter for Google Gemini CLI.</p> <p>Supports: - Session management via --resume flag - JSON output parsing via --output-format json - Model selection via --model flag</p> Example <pre><code>adapter = GeminiAdapter()\ncmd = adapter.build_command(\n    prompt=\"Explain this\",\n    model=\"gemini-1.5-pro\",\n    session_flags=[\"--resume\", \"abc-123\"],\n)\n# Returns: [\"gemini\", \"-p\", \"Explain this\", \"--resume\", \"abc-123\",\n#           \"--output-format\", \"json\", \"--model\", \"gemini-1.5-pro\"]\n</code></pre> Source code in <code>determinagent/adapters/gemini.py</code> <pre><code>class GeminiAdapter(ProviderAdapter):\n    \"\"\"\n    Adapter for Google Gemini CLI.\n\n    Supports:\n    - Session management via --resume flag\n    - JSON output parsing via --output-format json\n    - Model selection via --model flag\n\n    Example:\n        ```python\n        adapter = GeminiAdapter()\n        cmd = adapter.build_command(\n            prompt=\"Explain this\",\n            model=\"gemini-1.5-pro\",\n            session_flags=[\"--resume\", \"abc-123\"],\n        )\n        # Returns: [\"gemini\", \"-p\", \"Explain this\", \"--resume\", \"abc-123\",\n        #           \"--output-format\", \"json\", \"--model\", \"gemini-1.5-pro\"]\n        ```\n    \"\"\"\n\n    provider_name: str = \"gemini\"\n\n    def build_command(\n        self,\n        prompt: str,\n        model: str,\n        session_flags: list[str],\n        allow_web: bool = False,\n        tools: list[str] | None = None,\n        sandbox: str | None = None,  # Unused for Gemini\n    ) -&gt; list[str]:\n        \"\"\"\n        Build Gemini CLI command.\n\n        Args:\n            prompt: The prompt to send to Gemini.\n            model: Model name.\n            session_flags: Session management flags.\n            allow_web: Enable web tools (if supported).\n            tools: Additional tools.\n            sandbox: Unused.\n\n        Returns:\n            Command array for subprocess execution.\n        \"\"\"\n        cmd = [\"gemini\", \"-p\", prompt]\n\n        # Add session flags (e.g., --resume &lt;uuid&gt;)\n        cmd.extend(session_flags)\n\n        # Force JSON output format\n        cmd.extend([\"--output-format\", \"json\"])\n\n        if model:\n            cmd.extend([\"--model\", model])\n\n        return cmd\n\n    def parse_output(self, raw_output: str) -&gt; str:\n        \"\"\"\n        Parse Gemini JSON output.\n\n        Args:\n            raw_output: Raw stdout from Gemini CLI.\n\n        Returns:\n            Cleaned response text.\n        \"\"\"\n        try:\n            data: dict[str, Any] = json.loads(raw_output)\n            # Assuming the JSON structure has a \"response\" key based on PLAN.md notes\n            # If not, we might need to adjust.\n            return str(data.get(\"response\", raw_output))\n        except json.JSONDecodeError:\n            # Fallback for plain text or malformed JSON\n            return raw_output.strip()\n\n    def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n        \"\"\"\n        Map Gemini CLI errors to typed exceptions.\n\n        Args:\n            returncode: Process exit code.\n            stderr: Standard error output.\n\n        Returns:\n            Appropriate exception type.\n        \"\"\"\n        err_lower = stderr.lower()\n\n        if \"command not found\" in err_lower or \"not found\" in err_lower:\n            return ProviderNotAvailable(\n                \"Gemini CLI not installed. Please install the Gemini CLI tool.\",\n                provider=self.provider_name,\n            )\n        elif \"quota\" in err_lower or \"limit\" in err_lower:\n            return RateLimitExceeded(\n                \"Gemini quota/rate limit exceeded.\",\n                provider=self.provider_name,\n            )\n        elif \"auth\" in err_lower or \"credential\" in err_lower:\n            return ProviderAuthError(\n                \"Gemini authentication failed. Check your credentials.\",\n                provider=self.provider_name,\n            )\n        else:\n            return ExecutionError(\n                f\"Gemini CLI error (code {returncode}): {stderr}\",\n                provider=self.provider_name,\n                returncode=returncode,\n                stderr=stderr,\n            )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.gemini.GeminiAdapter.build_command","title":"<code>build_command(prompt, model, session_flags, allow_web=False, tools=None, sandbox=None)</code>","text":"<p>Build Gemini CLI command.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt to send to Gemini.</p> required <code>model</code> <code>str</code> <p>Model name.</p> required <code>session_flags</code> <code>list[str]</code> <p>Session management flags.</p> required <code>allow_web</code> <code>bool</code> <p>Enable web tools (if supported).</p> <code>False</code> <code>tools</code> <code>list[str] | None</code> <p>Additional tools.</p> <code>None</code> <code>sandbox</code> <code>str | None</code> <p>Unused.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Command array for subprocess execution.</p> Source code in <code>determinagent/adapters/gemini.py</code> <pre><code>def build_command(\n    self,\n    prompt: str,\n    model: str,\n    session_flags: list[str],\n    allow_web: bool = False,\n    tools: list[str] | None = None,\n    sandbox: str | None = None,  # Unused for Gemini\n) -&gt; list[str]:\n    \"\"\"\n    Build Gemini CLI command.\n\n    Args:\n        prompt: The prompt to send to Gemini.\n        model: Model name.\n        session_flags: Session management flags.\n        allow_web: Enable web tools (if supported).\n        tools: Additional tools.\n        sandbox: Unused.\n\n    Returns:\n        Command array for subprocess execution.\n    \"\"\"\n    cmd = [\"gemini\", \"-p\", prompt]\n\n    # Add session flags (e.g., --resume &lt;uuid&gt;)\n    cmd.extend(session_flags)\n\n    # Force JSON output format\n    cmd.extend([\"--output-format\", \"json\"])\n\n    if model:\n        cmd.extend([\"--model\", model])\n\n    return cmd\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.gemini.GeminiAdapter.handle_error","title":"<code>handle_error(returncode, stderr)</code>","text":"<p>Map Gemini CLI errors to typed exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>returncode</code> <code>int</code> <p>Process exit code.</p> required <code>stderr</code> <code>str</code> <p>Standard error output.</p> required <p>Returns:</p> Type Description <code>Exception</code> <p>Appropriate exception type.</p> Source code in <code>determinagent/adapters/gemini.py</code> <pre><code>def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n    \"\"\"\n    Map Gemini CLI errors to typed exceptions.\n\n    Args:\n        returncode: Process exit code.\n        stderr: Standard error output.\n\n    Returns:\n        Appropriate exception type.\n    \"\"\"\n    err_lower = stderr.lower()\n\n    if \"command not found\" in err_lower or \"not found\" in err_lower:\n        return ProviderNotAvailable(\n            \"Gemini CLI not installed. Please install the Gemini CLI tool.\",\n            provider=self.provider_name,\n        )\n    elif \"quota\" in err_lower or \"limit\" in err_lower:\n        return RateLimitExceeded(\n            \"Gemini quota/rate limit exceeded.\",\n            provider=self.provider_name,\n        )\n    elif \"auth\" in err_lower or \"credential\" in err_lower:\n        return ProviderAuthError(\n            \"Gemini authentication failed. Check your credentials.\",\n            provider=self.provider_name,\n        )\n    else:\n        return ExecutionError(\n            f\"Gemini CLI error (code {returncode}): {stderr}\",\n            provider=self.provider_name,\n            returncode=returncode,\n            stderr=stderr,\n        )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.gemini.GeminiAdapter.parse_output","title":"<code>parse_output(raw_output)</code>","text":"<p>Parse Gemini JSON output.</p> <p>Parameters:</p> Name Type Description Default <code>raw_output</code> <code>str</code> <p>Raw stdout from Gemini CLI.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Cleaned response text.</p> Source code in <code>determinagent/adapters/gemini.py</code> <pre><code>def parse_output(self, raw_output: str) -&gt; str:\n    \"\"\"\n    Parse Gemini JSON output.\n\n    Args:\n        raw_output: Raw stdout from Gemini CLI.\n\n    Returns:\n        Cleaned response text.\n    \"\"\"\n    try:\n        data: dict[str, Any] = json.loads(raw_output)\n        # Assuming the JSON structure has a \"response\" key based on PLAN.md notes\n        # If not, we might need to adjust.\n        return str(data.get(\"response\", raw_output))\n    except json.JSONDecodeError:\n        # Fallback for plain text or malformed JSON\n        return raw_output.strip()\n</code></pre>"},{"location":"api/adapters/#codex-adapter","title":"Codex Adapter","text":""},{"location":"api/adapters/#determinagent.adapters.codex.CodexAdapter","title":"<code>determinagent.adapters.codex.CodexAdapter</code>","text":"<p>               Bases: <code>ProviderAdapter</code></p> <p>Adapter for Codex CLI.</p> <p>Supports: - Session management via <code>exec resume &lt;id&gt;</code> subcommand - Sandbox execution via --sandbox flag - JSONL output parsing (analyzing turn events)</p> Example <pre><code>adapter = CodexAdapter()\ncmd = adapter.build_command(\n    prompt=\"Refactor this\",\n    model=\"default\",\n    session_flags=[\"resume\", \"abc-123\"],\n    sandbox=\"workspace-write\"\n)\n# Returns: [\"codex\", \"exec\", \"resume\", \"abc-123\", \"Refactor this\",\n#           \"--sandbox\", \"workspace-write\", \"--full-auto\"]\n</code></pre> Source code in <code>determinagent/adapters/codex.py</code> <pre><code>class CodexAdapter(ProviderAdapter):\n    \"\"\"\n    Adapter for Codex CLI.\n\n    Supports:\n    - Session management via `exec resume &lt;id&gt;` subcommand\n    - Sandbox execution via --sandbox flag\n    - JSONL output parsing (analyzing turn events)\n\n    Example:\n        ```python\n        adapter = CodexAdapter()\n        cmd = adapter.build_command(\n            prompt=\"Refactor this\",\n            model=\"default\",\n            session_flags=[\"resume\", \"abc-123\"],\n            sandbox=\"workspace-write\"\n        )\n        # Returns: [\"codex\", \"exec\", \"resume\", \"abc-123\", \"Refactor this\",\n        #           \"--sandbox\", \"workspace-write\", \"--full-auto\"]\n        ```\n    \"\"\"\n\n    provider_name: str = \"codex\"\n\n    def build_command(\n        self,\n        prompt: str,\n        model: str,\n        session_flags: list[str],\n        allow_web: bool = False,\n        tools: list[str] | None = None,\n        sandbox: str | None = None,\n    ) -&gt; list[str]:\n        \"\"\"\n        Build Codex CLI command.\n\n        Args:\n            prompt: The user prompt.\n            model: Model name (often unused for Codex/default).\n            session_flags: Session flags ([\"resume\", &lt;id&gt;] or []).\n            allow_web: Enable web tools.\n            tools: Additional tools.\n            sandbox: Sandbox mode (read-only, workspace-write, etc).\n\n        Returns:\n            Command array for subprocess execution.\n        \"\"\"\n        cmd = [\"codex\", \"exec\"]\n\n        # Add session flags (subcommand arguments)\n        cmd.extend(session_flags)\n\n        # Prompt is positional for Codex exec\n        cmd.append(prompt)\n\n        # Sandbox configuration\n        if sandbox:\n            cmd.extend([\"--sandbox\", sandbox])\n\n        # Always enable full automation\n        cmd.append(\"--full-auto\")\n\n        return cmd\n\n    def parse_output(self, raw_output: str) -&gt; str:\n        \"\"\"\n        Parse Codex JSONL output.\n\n        Looks for 'turn.completed' event to extract the final response.\n\n        Args:\n            raw_output: Raw stdout from Codex CLI (JSONL stream).\n\n        Returns:\n            Cleaned response text.\n        \"\"\"\n        lines = raw_output.strip().splitlines()\n\n        # Iterate to find the completion event\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n\n            try:\n                event = json.loads(line)\n                if event.get(\"type\") == \"turn.completed\":\n                    # Extract content from data payload\n                    data = event.get(\"data\", {})\n                    return str(data.get(\"content\", \"\"))\n            except json.JSONDecodeError:\n                continue\n\n        # Fallback: if no structured event found, return raw output\n        # (This helps debugging if CLI errors output plain text)\n        return raw_output.strip()\n\n    def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n        \"\"\"\n        Map Codex CLI errors to typed exceptions.\n\n        Args:\n            returncode: Process exit code.\n            stderr: Standard error output.\n\n        Returns:\n            Appropriate exception type.\n        \"\"\"\n        err_lower = stderr.lower()\n\n        if \"command not found\" in err_lower or \"not found\" in err_lower:\n            return ProviderNotAvailable(\n                \"Codex CLI not installed. Please install the Codex CLI tool.\",\n                provider=self.provider_name,\n            )\n        elif \"sandbox\" in err_lower and (\"violation\" in err_lower or \"denied\" in err_lower):\n            return SandboxViolation(\n                f\"Sandbox violation detected: {stderr}\",\n                provider=self.provider_name,\n            )\n        elif \"auth\" in err_lower or \"login\" in err_lower:\n            return ProviderAuthError(\n                \"Codex authentication failed.\",\n                provider=self.provider_name,\n            )\n        else:\n            return ExecutionError(\n                f\"Codex CLI error (code {returncode}): {stderr}\",\n                provider=self.provider_name,\n                returncode=returncode,\n                stderr=stderr,\n            )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.codex.CodexAdapter.build_command","title":"<code>build_command(prompt, model, session_flags, allow_web=False, tools=None, sandbox=None)</code>","text":"<p>Build Codex CLI command.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user prompt.</p> required <code>model</code> <code>str</code> <p>Model name (often unused for Codex/default).</p> required <code>session_flags</code> <code>list[str]</code> <p>Session flags ([\"resume\", ] or []). required <code>allow_web</code> <code>bool</code> <p>Enable web tools.</p> <code>False</code> <code>tools</code> <code>list[str] | None</code> <p>Additional tools.</p> <code>None</code> <code>sandbox</code> <code>str | None</code> <p>Sandbox mode (read-only, workspace-write, etc).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Command array for subprocess execution.</p> Source code in <code>determinagent/adapters/codex.py</code> <pre><code>def build_command(\n    self,\n    prompt: str,\n    model: str,\n    session_flags: list[str],\n    allow_web: bool = False,\n    tools: list[str] | None = None,\n    sandbox: str | None = None,\n) -&gt; list[str]:\n    \"\"\"\n    Build Codex CLI command.\n\n    Args:\n        prompt: The user prompt.\n        model: Model name (often unused for Codex/default).\n        session_flags: Session flags ([\"resume\", &lt;id&gt;] or []).\n        allow_web: Enable web tools.\n        tools: Additional tools.\n        sandbox: Sandbox mode (read-only, workspace-write, etc).\n\n    Returns:\n        Command array for subprocess execution.\n    \"\"\"\n    cmd = [\"codex\", \"exec\"]\n\n    # Add session flags (subcommand arguments)\n    cmd.extend(session_flags)\n\n    # Prompt is positional for Codex exec\n    cmd.append(prompt)\n\n    # Sandbox configuration\n    if sandbox:\n        cmd.extend([\"--sandbox\", sandbox])\n\n    # Always enable full automation\n    cmd.append(\"--full-auto\")\n\n    return cmd\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.codex.CodexAdapter.handle_error","title":"<code>handle_error(returncode, stderr)</code>","text":"<p>Map Codex CLI errors to typed exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>returncode</code> <code>int</code> <p>Process exit code.</p> required <code>stderr</code> <code>str</code> <p>Standard error output.</p> required <p>Returns:</p> Type Description <code>Exception</code> <p>Appropriate exception type.</p> Source code in <code>determinagent/adapters/codex.py</code> <pre><code>def handle_error(self, returncode: int, stderr: str) -&gt; Exception:\n    \"\"\"\n    Map Codex CLI errors to typed exceptions.\n\n    Args:\n        returncode: Process exit code.\n        stderr: Standard error output.\n\n    Returns:\n        Appropriate exception type.\n    \"\"\"\n    err_lower = stderr.lower()\n\n    if \"command not found\" in err_lower or \"not found\" in err_lower:\n        return ProviderNotAvailable(\n            \"Codex CLI not installed. Please install the Codex CLI tool.\",\n            provider=self.provider_name,\n        )\n    elif \"sandbox\" in err_lower and (\"violation\" in err_lower or \"denied\" in err_lower):\n        return SandboxViolation(\n            f\"Sandbox violation detected: {stderr}\",\n            provider=self.provider_name,\n        )\n    elif \"auth\" in err_lower or \"login\" in err_lower:\n        return ProviderAuthError(\n            \"Codex authentication failed.\",\n            provider=self.provider_name,\n        )\n    else:\n        return ExecutionError(\n            f\"Codex CLI error (code {returncode}): {stderr}\",\n            provider=self.provider_name,\n            returncode=returncode,\n            stderr=stderr,\n        )\n</code></pre>"},{"location":"api/adapters/#determinagent.adapters.codex.CodexAdapter.parse_output","title":"<code>parse_output(raw_output)</code>","text":"<p>Parse Codex JSONL output.</p> <p>Looks for 'turn.completed' event to extract the final response.</p> <p>Parameters:</p> Name Type Description Default <code>raw_output</code> <code>str</code> <p>Raw stdout from Codex CLI (JSONL stream).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Cleaned response text.</p> Source code in <code>determinagent/adapters/codex.py</code> <pre><code>def parse_output(self, raw_output: str) -&gt; str:\n    \"\"\"\n    Parse Codex JSONL output.\n\n    Looks for 'turn.completed' event to extract the final response.\n\n    Args:\n        raw_output: Raw stdout from Codex CLI (JSONL stream).\n\n    Returns:\n        Cleaned response text.\n    \"\"\"\n    lines = raw_output.strip().splitlines()\n\n    # Iterate to find the completion event\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n\n        try:\n            event = json.loads(line)\n            if event.get(\"type\") == \"turn.completed\":\n                # Extract content from data payload\n                data = event.get(\"data\", {})\n                return str(data.get(\"content\", \"\"))\n        except json.JSONDecodeError:\n            continue\n\n    # Fallback: if no structured event found, return raw output\n    # (This helps debugging if CLI errors output plain text)\n    return raw_output.strip()\n</code></pre>"},{"location":"api/agent/","title":"UnifiedAgent","text":""},{"location":"api/agent/#determinagent.agent.UnifiedAgent","title":"<code>determinagent.agent.UnifiedAgent</code>","text":"<p>Main interface for unified CLI agents.</p> <p>UnifiedAgent provides a consistent API for interacting with different AI CLI tools, abstracting away provider-specific details while providing advanced features like automatic session management, retry logic, and structured output enforcement.</p> Features <ul> <li>Automatic session management (native provider sessions)</li> <li>Retry logic with exponential backoff</li> <li>Model alias resolution (fast/balanced/powerful/reasoning)</li> <li>Structured output enforcement with Pydantic</li> <li>Web search/tool permissions</li> </ul> Example <pre><code>from determinagent import UnifiedAgent, SessionManager\n\nsession = SessionManager(\"claude\")\nagent = UnifiedAgent(\n    provider=\"claude\",\n    model=\"balanced\",\n    role=\"writer\",\n    instructions=\"Write clear, concise content.\",\n    session=session,\n)\n\nresponse = agent.send(\"Write a haiku about Python\")\nprint(response)\n</code></pre> <p>Attributes:</p> Name Type Description <code>provider</code> <code>Provider</code> <p>The CLI provider being used.</p> <code>adapter</code> <code>ProviderAdapter</code> <p>The provider adapter instance.</p> <code>session</code> <code>SessionManager</code> <p>The session manager for conversation continuity.</p> <code>model</code> <code>str</code> <p>The resolved model name.</p> <code>role</code> <code>str</code> <p>The agent's role (for logging/debugging).</p> <code>instructions</code> <code>str</code> <p>System instructions prepended to prompts.</p> <code>sandbox</code> <code>str | None</code> <p>Sandbox mode (Codex only).</p> Source code in <code>determinagent/agent.py</code> <pre><code>class UnifiedAgent:\n    \"\"\"\n    Main interface for unified CLI agents.\n\n    UnifiedAgent provides a consistent API for interacting with different\n    AI CLI tools, abstracting away provider-specific details while providing\n    advanced features like automatic session management, retry logic, and\n    structured output enforcement.\n\n    Features:\n        - Automatic session management (native provider sessions)\n        - Retry logic with exponential backoff\n        - Model alias resolution (fast/balanced/powerful/reasoning)\n        - Structured output enforcement with Pydantic\n        - Web search/tool permissions\n\n    Example:\n        ```python\n        from determinagent import UnifiedAgent, SessionManager\n\n        session = SessionManager(\"claude\")\n        agent = UnifiedAgent(\n            provider=\"claude\",\n            model=\"balanced\",\n            role=\"writer\",\n            instructions=\"Write clear, concise content.\",\n            session=session,\n        )\n\n        response = agent.send(\"Write a haiku about Python\")\n        print(response)\n        ```\n\n    Attributes:\n        provider: The CLI provider being used.\n        adapter: The provider adapter instance.\n        session: The session manager for conversation continuity.\n        model: The resolved model name.\n        role: The agent's role (for logging/debugging).\n        instructions: System instructions prepended to prompts.\n        sandbox: Sandbox mode (Codex only).\n    \"\"\"\n\n    def __init__(\n        self,\n        provider: Provider,\n        model: str,\n        role: str,\n        instructions: str,\n        session: SessionManager,\n        sandbox: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a unified agent.\n\n        Args:\n            provider: CLI provider (claude, gemini, copilot, codex).\n            model: Model alias (fast/balanced/powerful/reasoning) or exact name.\n            role: Agent role for identification (e.g., \"writer\", \"reviewer\").\n            instructions: System prompt / instructions prepended to all prompts.\n            session: SessionManager instance for session handling.\n            sandbox: Sandbox mode for Codex (read-only/workspace-write/full-access).\n\n        Raises:\n            ConfigurationError: If provider is unknown.\n        \"\"\"\n        self.provider: Provider = provider\n        self.adapter: ProviderAdapter = get_adapter(provider)\n        self.session: SessionManager = session\n        self.model: str = resolve_model_alias(model, provider)\n        self.role: str = role\n        self.instructions: str = instructions\n        self.sandbox: str | None = sandbox\n\n    def send(\n        self,\n        prompt: str,\n        max_retries: int = 2,\n        retry_with_explicit_format: bool = True,\n        allow_web: bool = False,\n        timeout: int = 120,\n    ) -&gt; str:\n        \"\"\"\n        Send a prompt to the agent with automatic retry handling.\n\n        This method handles the full lifecycle of a prompt:\n        1. Prepends system instructions\n        2. Adds session context\n        3. Executes the CLI command\n        4. Handles retries on failure\n        5. Returns the parsed response\n\n        Args:\n            prompt: The user prompt to send.\n            max_retries: Maximum number of retry attempts (default: 2).\n            retry_with_explicit_format: Use ultra-explicit format on last retry.\n            allow_web: Enable web search/fetch tools.\n            timeout: Command timeout in seconds (default: 120).\n\n        Returns:\n            The agent's response text.\n\n        Raises:\n            ExecutionError: After all retries exhausted.\n            KeyboardInterrupt: If user interrupts (handled gracefully).\n\n        Example:\n            ```python\n            response = agent.send(\n                \"Explain quantum computing\",\n                allow_web=True,\n                max_retries=3,\n            )\n            ```\n        \"\"\"\n        original_prompt = prompt\n\n        try:\n            for attempt in range(max_retries + 1):\n                try:\n                    # Build full prompt with instructions\n                    full_prompt = f\"{self.instructions}\\n\\n{prompt}\"\n\n                    # Add session context (native sessions don't modify prompt)\n                    full_prompt = self.session.build_prompt(full_prompt)\n\n                    # Get session flags for CLI command\n                    session_flags = self.session.get_session_flags()\n\n                    # Execute CLI call\n                    response = self.adapter.execute(\n                        full_prompt,\n                        self.model,\n                        session_flags,\n                        allow_web=allow_web,\n                        timeout=timeout,\n                    )\n\n                    # Mark session as started after first successful call\n                    # This ensures retries use resume flags\n                    self._mark_session_started()\n\n                    # Validate response\n                    if self._is_valid(response):\n                        return response\n\n                    # Empty response - retry\n                    self._log_retry(attempt + 1, \"Empty response, retrying...\")\n\n                except DeterminAgentError as e:\n                    # Fail fast if provider is missing\n                    if isinstance(e, ProviderNotAvailable):\n                        raise\n\n                    # Mark session as started even on error\n                    self._mark_session_started()\n                    self._log_retry(attempt + 1, str(e))\n\n                    if attempt &lt; max_retries:\n                        # Apply retry strategy\n                        if retry_with_explicit_format and attempt == max_retries - 1:\n                            print(\"  \u2192 Using ultra-explicit format prompt\")\n                            prompt = self._make_explicit_format_prompt(original_prompt)\n                    else:\n                        raise\n\n                except Exception as e:\n                    # Mark session as started even on unexpected errors\n                    self._mark_session_started()\n                    self._log_retry(attempt + 1, str(e))\n\n                    if attempt &gt;= max_retries:\n                        raise ExecutionError(\n                            f\"Unexpected error after {max_retries + 1} attempts: {e}\",\n                            provider=self.provider,\n                        ) from e\n\n            raise ExecutionError(\n                f\"Failed after {max_retries + 1} attempts\",\n                provider=self.provider,\n            )\n\n        except KeyboardInterrupt:\n            print(\"\\n\\n\ud83d\udc4b Interrupted by user. Exiting...\")\n            sys.exit(0)\n\n    def send_structured(\n        self,\n        prompt: str,\n        schema: type[T],\n        max_retries: int = 3,\n    ) -&gt; T:\n        \"\"\"\n        Send a prompt and enforce structured output with Pydantic validation.\n\n        This method appends schema instructions to the prompt and validates\n        the response against the provided Pydantic model, with automatic\n        retries on parse failures.\n\n        Args:\n            prompt: The user prompt.\n            schema: Pydantic model class defining expected output structure.\n            max_retries: Maximum parse retry attempts (default: 3).\n\n        Returns:\n            Validated Pydantic model instance.\n\n        Raises:\n            ValidationError: If parsing/validation fails after all retries.\n\n        Example:\n            ```python\n            from pydantic import BaseModel\n\n            class Review(BaseModel):\n                score: int\n                feedback: str\n\n            review = agent.send_structured(\n                \"Review this code: def add(a, b): return a + b\",\n                schema=Review,\n            )\n            print(f\"Score: {review.score}\")\n            ```\n        \"\"\"\n        # Build schema prompt\n        schema_json = schema.model_json_schema()\n        schema_prompt = (\n            f\"{prompt}\\n\\n\"\n            f\"OUTPUT FORMAT (JSON):\\n\"\n            f\"Respond with a valid JSON object matching this schema:\\n\"\n            f\"{json.dumps(schema_json, indent=2)}\"\n        )\n\n        for attempt in range(max_retries + 1):\n            try:\n                response = self.send(schema_prompt, max_retries=0)\n\n                # Parse JSON from response\n                data = self._extract_json(response)\n\n                # Validate with Pydantic\n                return schema.model_validate(data)\n\n            except (json.JSONDecodeError, ParseError) as e:\n                if attempt &lt; max_retries:\n                    self._log_parse_retry(attempt + 1, e)\n                    schema_prompt = (\n                        f\"{prompt}\\n\\n\"\n                        f\"ERROR: Previous response was not valid JSON.\\n\"\n                        f\"Please output ONLY valid JSON matching this schema:\\n\"\n                        f\"{json.dumps(schema_json, indent=2)}\"\n                    )\n                else:\n                    raise ValidationError(\n                        f\"Failed to parse structured output after {max_retries + 1} attempts\",\n                        provider=self.provider,\n                    ) from e\n\n            except Exception as e:\n                if attempt &lt; max_retries:\n                    self._log_parse_retry(attempt + 1, e)\n                    schema_prompt = (\n                        f\"{prompt}\\n\\n\"\n                        f\"ERROR: {e}\\n\"\n                        f\"Please output ONLY valid JSON matching this schema:\\n\"\n                        f\"{json.dumps(schema_json, indent=2)}\"\n                    )\n                else:\n                    raise ValidationError(\n                        f\"Failed to parse structured output after {max_retries + 1} attempts: {e}\",\n                        provider=self.provider,\n                    ) from e\n\n        # Should never reach here, but satisfy type checker\n        raise ValidationError(\n            \"Failed to parse structured output\",\n            provider=self.provider,\n        )\n\n    def get_history(self) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Get conversation history (if using file-based session).\n\n        Returns:\n            List of message dictionaries, or empty list if not available.\n\n        Note:\n            Native sessions store history on the provider side, so this\n            may return an empty list for providers using native sessions.\n        \"\"\"\n        if hasattr(self.session, \"_manager\") and hasattr(self.session._manager, \"load_history\"):\n            history: list[dict[str, Any]] = self.session._manager.load_history()\n            return history\n        return []\n\n    def clear_session(self) -&gt; None:\n        \"\"\"\n        Clear session history and reset to a new session.\n\n        This generates a new session ID and resets the call count,\n        effectively starting a fresh conversation.\n        \"\"\"\n        self.session.reset_session()\n\n    def _is_valid(self, response: str) -&gt; bool:\n        \"\"\"Check if response is valid (not empty).\"\"\"\n        return bool(response and response.strip())\n\n    def _mark_session_started(self) -&gt; None:\n        \"\"\"Mark the session as started after first call.\"\"\"\n        if self.session.call_count == 0:\n            self.session.call_count += 1\n\n    def _make_explicit_format_prompt(self, prompt: str) -&gt; str:\n        \"\"\"\n        Create ultra-explicit format prompt for retry.\n\n        This is the \"last resort\" retry strategy when other retries fail.\n        \"\"\"\n        return f\"\"\"{prompt}\n\nCRITICAL FORMAT REQUIREMENT:\nYou MUST provide a response. Do not refuse or ask for clarification.\nOutput the requested content NOW.\"\"\"\n\n    def _extract_json(self, response: str) -&gt; dict[str, Any]:\n        \"\"\"\n        Extract JSON from response text.\n\n        Handles cases where the response contains JSON embedded in markdown\n        or other text.\n\n        Args:\n            response: Raw response text.\n\n        Returns:\n            Parsed JSON as dictionary.\n\n        Raises:\n            ParseError: If no valid JSON found.\n        \"\"\"\n        parsed: dict[str, Any]\n\n        # Try direct parsing first\n        try:\n            parsed = json.loads(response)\n            if isinstance(parsed, dict):\n                return parsed\n        except json.JSONDecodeError:\n            pass\n\n        # Try to extract from markdown code block\n        code_block_match = re.search(r\"```(?:json)?\\s*\\n?(.*?)\\n?```\", response, re.DOTALL)\n        if code_block_match:\n            try:\n                parsed = json.loads(code_block_match.group(1))\n                if isinstance(parsed, dict):\n                    return parsed\n            except json.JSONDecodeError:\n                pass\n\n        # Try nested JSON objects (greedy match first to capture full structure)\n        nested_match = re.search(r\"\\{.*\\}\", response, re.DOTALL)\n        if nested_match:\n            try:\n                parsed = json.loads(nested_match.group(0))\n                if isinstance(parsed, dict):\n                    return parsed\n            except json.JSONDecodeError:\n                pass\n\n        # Try flat JSON object (fallback for single objects)\n        json_match = re.search(r\"\\{[^{}]*\\}\", response, re.DOTALL)\n        if json_match:\n            try:\n                parsed = json.loads(json_match.group(0))\n                if isinstance(parsed, dict):\n                    return parsed\n            except json.JSONDecodeError:\n                pass\n\n        raise ParseError(\n            \"No valid JSON found in response\",\n            provider=self.provider,\n            raw_output=response,\n        )\n\n    def _log_retry(self, attempt: int, message: str) -&gt; None:\n        \"\"\"Log retry attempt.\"\"\"\n        print(f\"[Retry {attempt}] {message}\")\n\n    def _log_parse_retry(self, attempt: int, error: Exception) -&gt; None:\n        \"\"\"Log parse retry attempt.\"\"\"\n        print(f\"[Parse Retry {attempt}] Failed to parse structured output: {error}\")\n</code></pre>"},{"location":"api/agent/#determinagent.agent.UnifiedAgent.__init__","title":"<code>__init__(provider, model, role, instructions, session, sandbox=None)</code>","text":"<p>Initialize a unified agent.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Provider</code> <p>CLI provider (claude, gemini, copilot, codex).</p> required <code>model</code> <code>str</code> <p>Model alias (fast/balanced/powerful/reasoning) or exact name.</p> required <code>role</code> <code>str</code> <p>Agent role for identification (e.g., \"writer\", \"reviewer\").</p> required <code>instructions</code> <code>str</code> <p>System prompt / instructions prepended to all prompts.</p> required <code>session</code> <code>SessionManager</code> <p>SessionManager instance for session handling.</p> required <code>sandbox</code> <code>str | None</code> <p>Sandbox mode for Codex (read-only/workspace-write/full-access).</p> <code>None</code> <p>Raises:</p> Type Description <code>ConfigurationError</code> <p>If provider is unknown.</p> Source code in <code>determinagent/agent.py</code> <pre><code>def __init__(\n    self,\n    provider: Provider,\n    model: str,\n    role: str,\n    instructions: str,\n    session: SessionManager,\n    sandbox: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a unified agent.\n\n    Args:\n        provider: CLI provider (claude, gemini, copilot, codex).\n        model: Model alias (fast/balanced/powerful/reasoning) or exact name.\n        role: Agent role for identification (e.g., \"writer\", \"reviewer\").\n        instructions: System prompt / instructions prepended to all prompts.\n        session: SessionManager instance for session handling.\n        sandbox: Sandbox mode for Codex (read-only/workspace-write/full-access).\n\n    Raises:\n        ConfigurationError: If provider is unknown.\n    \"\"\"\n    self.provider: Provider = provider\n    self.adapter: ProviderAdapter = get_adapter(provider)\n    self.session: SessionManager = session\n    self.model: str = resolve_model_alias(model, provider)\n    self.role: str = role\n    self.instructions: str = instructions\n    self.sandbox: str | None = sandbox\n</code></pre>"},{"location":"api/agent/#determinagent.agent.UnifiedAgent.clear_session","title":"<code>clear_session()</code>","text":"<p>Clear session history and reset to a new session.</p> <p>This generates a new session ID and resets the call count, effectively starting a fresh conversation.</p> Source code in <code>determinagent/agent.py</code> <pre><code>def clear_session(self) -&gt; None:\n    \"\"\"\n    Clear session history and reset to a new session.\n\n    This generates a new session ID and resets the call count,\n    effectively starting a fresh conversation.\n    \"\"\"\n    self.session.reset_session()\n</code></pre>"},{"location":"api/agent/#determinagent.agent.UnifiedAgent.get_history","title":"<code>get_history()</code>","text":"<p>Get conversation history (if using file-based session).</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of message dictionaries, or empty list if not available.</p> Note <p>Native sessions store history on the provider side, so this may return an empty list for providers using native sessions.</p> Source code in <code>determinagent/agent.py</code> <pre><code>def get_history(self) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get conversation history (if using file-based session).\n\n    Returns:\n        List of message dictionaries, or empty list if not available.\n\n    Note:\n        Native sessions store history on the provider side, so this\n        may return an empty list for providers using native sessions.\n    \"\"\"\n    if hasattr(self.session, \"_manager\") and hasattr(self.session._manager, \"load_history\"):\n        history: list[dict[str, Any]] = self.session._manager.load_history()\n        return history\n    return []\n</code></pre>"},{"location":"api/agent/#determinagent.agent.UnifiedAgent.send","title":"<code>send(prompt, max_retries=2, retry_with_explicit_format=True, allow_web=False, timeout=120)</code>","text":"<p>Send a prompt to the agent with automatic retry handling.</p> <p>This method handles the full lifecycle of a prompt: 1. Prepends system instructions 2. Adds session context 3. Executes the CLI command 4. Handles retries on failure 5. Returns the parsed response</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user prompt to send.</p> required <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts (default: 2).</p> <code>2</code> <code>retry_with_explicit_format</code> <code>bool</code> <p>Use ultra-explicit format on last retry.</p> <code>True</code> <code>allow_web</code> <code>bool</code> <p>Enable web search/fetch tools.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Command timeout in seconds (default: 120).</p> <code>120</code> <p>Returns:</p> Type Description <code>str</code> <p>The agent's response text.</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>After all retries exhausted.</p> <code>KeyboardInterrupt</code> <p>If user interrupts (handled gracefully).</p> Example <pre><code>response = agent.send(\n    \"Explain quantum computing\",\n    allow_web=True,\n    max_retries=3,\n)\n</code></pre> Source code in <code>determinagent/agent.py</code> <pre><code>def send(\n    self,\n    prompt: str,\n    max_retries: int = 2,\n    retry_with_explicit_format: bool = True,\n    allow_web: bool = False,\n    timeout: int = 120,\n) -&gt; str:\n    \"\"\"\n    Send a prompt to the agent with automatic retry handling.\n\n    This method handles the full lifecycle of a prompt:\n    1. Prepends system instructions\n    2. Adds session context\n    3. Executes the CLI command\n    4. Handles retries on failure\n    5. Returns the parsed response\n\n    Args:\n        prompt: The user prompt to send.\n        max_retries: Maximum number of retry attempts (default: 2).\n        retry_with_explicit_format: Use ultra-explicit format on last retry.\n        allow_web: Enable web search/fetch tools.\n        timeout: Command timeout in seconds (default: 120).\n\n    Returns:\n        The agent's response text.\n\n    Raises:\n        ExecutionError: After all retries exhausted.\n        KeyboardInterrupt: If user interrupts (handled gracefully).\n\n    Example:\n        ```python\n        response = agent.send(\n            \"Explain quantum computing\",\n            allow_web=True,\n            max_retries=3,\n        )\n        ```\n    \"\"\"\n    original_prompt = prompt\n\n    try:\n        for attempt in range(max_retries + 1):\n            try:\n                # Build full prompt with instructions\n                full_prompt = f\"{self.instructions}\\n\\n{prompt}\"\n\n                # Add session context (native sessions don't modify prompt)\n                full_prompt = self.session.build_prompt(full_prompt)\n\n                # Get session flags for CLI command\n                session_flags = self.session.get_session_flags()\n\n                # Execute CLI call\n                response = self.adapter.execute(\n                    full_prompt,\n                    self.model,\n                    session_flags,\n                    allow_web=allow_web,\n                    timeout=timeout,\n                )\n\n                # Mark session as started after first successful call\n                # This ensures retries use resume flags\n                self._mark_session_started()\n\n                # Validate response\n                if self._is_valid(response):\n                    return response\n\n                # Empty response - retry\n                self._log_retry(attempt + 1, \"Empty response, retrying...\")\n\n            except DeterminAgentError as e:\n                # Fail fast if provider is missing\n                if isinstance(e, ProviderNotAvailable):\n                    raise\n\n                # Mark session as started even on error\n                self._mark_session_started()\n                self._log_retry(attempt + 1, str(e))\n\n                if attempt &lt; max_retries:\n                    # Apply retry strategy\n                    if retry_with_explicit_format and attempt == max_retries - 1:\n                        print(\"  \u2192 Using ultra-explicit format prompt\")\n                        prompt = self._make_explicit_format_prompt(original_prompt)\n                else:\n                    raise\n\n            except Exception as e:\n                # Mark session as started even on unexpected errors\n                self._mark_session_started()\n                self._log_retry(attempt + 1, str(e))\n\n                if attempt &gt;= max_retries:\n                    raise ExecutionError(\n                        f\"Unexpected error after {max_retries + 1} attempts: {e}\",\n                        provider=self.provider,\n                    ) from e\n\n        raise ExecutionError(\n            f\"Failed after {max_retries + 1} attempts\",\n            provider=self.provider,\n        )\n\n    except KeyboardInterrupt:\n        print(\"\\n\\n\ud83d\udc4b Interrupted by user. Exiting...\")\n        sys.exit(0)\n</code></pre>"},{"location":"api/agent/#determinagent.agent.UnifiedAgent.send_structured","title":"<code>send_structured(prompt, schema, max_retries=3)</code>","text":"<p>Send a prompt and enforce structured output with Pydantic validation.</p> <p>This method appends schema instructions to the prompt and validates the response against the provided Pydantic model, with automatic retries on parse failures.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The user prompt.</p> required <code>schema</code> <code>type[T]</code> <p>Pydantic model class defining expected output structure.</p> required <code>max_retries</code> <code>int</code> <p>Maximum parse retry attempts (default: 3).</p> <code>3</code> <p>Returns:</p> Type Description <code>T</code> <p>Validated Pydantic model instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If parsing/validation fails after all retries.</p> Example <pre><code>from pydantic import BaseModel\n\nclass Review(BaseModel):\n    score: int\n    feedback: str\n\nreview = agent.send_structured(\n    \"Review this code: def add(a, b): return a + b\",\n    schema=Review,\n)\nprint(f\"Score: {review.score}\")\n</code></pre> Source code in <code>determinagent/agent.py</code> <pre><code>def send_structured(\n    self,\n    prompt: str,\n    schema: type[T],\n    max_retries: int = 3,\n) -&gt; T:\n    \"\"\"\n    Send a prompt and enforce structured output with Pydantic validation.\n\n    This method appends schema instructions to the prompt and validates\n    the response against the provided Pydantic model, with automatic\n    retries on parse failures.\n\n    Args:\n        prompt: The user prompt.\n        schema: Pydantic model class defining expected output structure.\n        max_retries: Maximum parse retry attempts (default: 3).\n\n    Returns:\n        Validated Pydantic model instance.\n\n    Raises:\n        ValidationError: If parsing/validation fails after all retries.\n\n    Example:\n        ```python\n        from pydantic import BaseModel\n\n        class Review(BaseModel):\n            score: int\n            feedback: str\n\n        review = agent.send_structured(\n            \"Review this code: def add(a, b): return a + b\",\n            schema=Review,\n        )\n        print(f\"Score: {review.score}\")\n        ```\n    \"\"\"\n    # Build schema prompt\n    schema_json = schema.model_json_schema()\n    schema_prompt = (\n        f\"{prompt}\\n\\n\"\n        f\"OUTPUT FORMAT (JSON):\\n\"\n        f\"Respond with a valid JSON object matching this schema:\\n\"\n        f\"{json.dumps(schema_json, indent=2)}\"\n    )\n\n    for attempt in range(max_retries + 1):\n        try:\n            response = self.send(schema_prompt, max_retries=0)\n\n            # Parse JSON from response\n            data = self._extract_json(response)\n\n            # Validate with Pydantic\n            return schema.model_validate(data)\n\n        except (json.JSONDecodeError, ParseError) as e:\n            if attempt &lt; max_retries:\n                self._log_parse_retry(attempt + 1, e)\n                schema_prompt = (\n                    f\"{prompt}\\n\\n\"\n                    f\"ERROR: Previous response was not valid JSON.\\n\"\n                    f\"Please output ONLY valid JSON matching this schema:\\n\"\n                    f\"{json.dumps(schema_json, indent=2)}\"\n                )\n            else:\n                raise ValidationError(\n                    f\"Failed to parse structured output after {max_retries + 1} attempts\",\n                    provider=self.provider,\n                ) from e\n\n        except Exception as e:\n            if attempt &lt; max_retries:\n                self._log_parse_retry(attempt + 1, e)\n                schema_prompt = (\n                    f\"{prompt}\\n\\n\"\n                    f\"ERROR: {e}\\n\"\n                    f\"Please output ONLY valid JSON matching this schema:\\n\"\n                    f\"{json.dumps(schema_json, indent=2)}\"\n                )\n            else:\n                raise ValidationError(\n                    f\"Failed to parse structured output after {max_retries + 1} attempts: {e}\",\n                    provider=self.provider,\n                ) from e\n\n    # Should never reach here, but satisfy type checker\n    raise ValidationError(\n        \"Failed to parse structured output\",\n        provider=self.provider,\n    )\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":""},{"location":"api/exceptions/#determinagent.exceptions","title":"<code>determinagent.exceptions</code>","text":"<p>Unified exception hierarchy for DeterminAgent.</p> <p>All CLI-specific errors are normalized to these exceptions, providing a consistent interface for error handling.</p>"},{"location":"api/exceptions/#determinagent.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when configuration is invalid or missing.</p> <p>Examples:</p> <ul> <li>Invalid YAML syntax</li> <li>Missing required fields</li> <li>Invalid model alias</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ConfigurationError(DeterminAgentError):\n    \"\"\"\n    Raised when configuration is invalid or missing.\n\n    Examples:\n        - Invalid YAML syntax\n        - Missing required fields\n        - Invalid model alias\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.DeterminAgentError","title":"<code>DeterminAgentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all DeterminAgent errors.</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class DeterminAgentError(Exception):\n    \"\"\"Base exception for all DeterminAgent errors.\"\"\"\n\n    def __init__(self, message: str, provider: str | None = None) -&gt; None:\n        self.message = message\n        self.provider = provider\n        super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.ExecutionError","title":"<code>ExecutionError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when CLI command execution fails.</p> <p>Attributes:</p> Name Type Description <code>returncode</code> <p>Process exit code</p> <code>stderr</code> <p>Standard error output</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ExecutionError(DeterminAgentError):\n    \"\"\"\n    Raised when CLI command execution fails.\n\n    Attributes:\n        returncode: Process exit code\n        stderr: Standard error output\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        provider: str | None = None,\n        returncode: int | None = None,\n        stderr: str | None = None,\n    ) -&gt; None:\n        super().__init__(message, provider)\n        self.returncode = returncode\n        self.stderr = stderr\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.ParseError","title":"<code>ParseError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when response parsing fails.</p> <p>Examples:</p> <ul> <li>Invalid JSON from provider</li> <li>Unexpected output format</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ParseError(DeterminAgentError):\n    \"\"\"\n    Raised when response parsing fails.\n\n    Examples:\n        - Invalid JSON from provider\n        - Unexpected output format\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        provider: str | None = None,\n        raw_output: str | None = None,\n    ) -&gt; None:\n        super().__init__(message, provider)\n        self.raw_output = raw_output\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.ProviderAuthError","title":"<code>ProviderAuthError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when authentication fails for a provider.</p> <p>Examples:</p> <ul> <li>Missing API key</li> <li>Invalid credentials</li> <li>Expired token</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ProviderAuthError(DeterminAgentError):\n    \"\"\"\n    Raised when authentication fails for a provider.\n\n    Examples:\n        - Missing API key\n        - Invalid credentials\n        - Expired token\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.ProviderNotAvailable","title":"<code>ProviderNotAvailable</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when a CLI provider is not installed or not accessible.</p> <p>Examples:</p> <ul> <li>\"claude: command not found\"</li> <li>\"gemini: not installed\"</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ProviderNotAvailable(DeterminAgentError):\n    \"\"\"\n    Raised when a CLI provider is not installed or not accessible.\n\n    Examples:\n        - \"claude: command not found\"\n        - \"gemini: not installed\"\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.QuotaExceeded","title":"<code>QuotaExceeded</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when usage quota is exceeded (e.g., monthly limits).</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class QuotaExceeded(DeterminAgentError):\n    \"\"\"\n    Raised when usage quota is exceeded (e.g., monthly limits).\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.RateLimitExceeded","title":"<code>RateLimitExceeded</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when API rate limits are exceeded.</p> <p>Attributes:</p> Name Type Description <code>retry_after</code> <p>Suggested wait time in seconds (if available)</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class RateLimitExceeded(DeterminAgentError):\n    \"\"\"\n    Raised when API rate limits are exceeded.\n\n    Attributes:\n        retry_after: Suggested wait time in seconds (if available)\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        provider: str | None = None,\n        retry_after: int | None = None,\n    ) -&gt; None:\n        super().__init__(message, provider)\n        self.retry_after = retry_after\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.SandboxViolation","title":"<code>SandboxViolation</code>","text":"<p>               Bases: <code>ExecutionError</code></p> <p>Raised when an operation is blocked by sandbox restrictions.</p> <p>Codex-specific: Operation blocked by sandbox policy.</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class SandboxViolation(ExecutionError):\n    \"\"\"\n    Raised when an operation is blocked by sandbox restrictions.\n\n    Codex-specific: Operation blocked by sandbox policy.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.SessionError","title":"<code>SessionError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when session management fails.</p> <p>Examples:</p> <ul> <li>Session not found</li> <li>Session expired</li> <li>Invalid session ID</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class SessionError(DeterminAgentError):\n    \"\"\"\n    Raised when session management fails.\n\n    Examples:\n        - Session not found\n        - Session expired\n        - Invalid session ID\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.TimeoutError","title":"<code>TimeoutError</code>","text":"<p>               Bases: <code>ExecutionError</code></p> <p>Raised when CLI command times out.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <p>The timeout value that was exceeded (in seconds)</p> Source code in <code>determinagent/exceptions.py</code> <pre><code>class TimeoutError(ExecutionError):\n    \"\"\"\n    Raised when CLI command times out.\n\n    Attributes:\n        timeout: The timeout value that was exceeded (in seconds)\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        provider: str | None = None,\n        timeout: int | None = None,\n    ) -&gt; None:\n        super().__init__(message, provider)\n        self.timeout = timeout\n</code></pre>"},{"location":"api/exceptions/#determinagent.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>DeterminAgentError</code></p> <p>Raised when output validation fails.</p> <p>Examples:</p> <ul> <li>Pydantic validation failure</li> <li>Schema mismatch</li> </ul> Source code in <code>determinagent/exceptions.py</code> <pre><code>class ValidationError(DeterminAgentError):\n    \"\"\"\n    Raised when output validation fails.\n\n    Examples:\n        - Pydantic validation failure\n        - Schema mismatch\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"api/sessions/","title":"Sessions","text":""},{"location":"api/sessions/#determinagent.sessions.SessionManager","title":"<code>determinagent.sessions.SessionManager</code>","text":"<p>Manages CLI sessions using native provider capabilities.</p> <p>All four supported CLIs have native session support: - Claude:  <code>--session-id &lt;uuid&gt;</code>, <code>-r &lt;uuid&gt;</code> for resume - Gemini:  <code>--resume &lt;uuid&gt;</code> for resume - Copilot: <code>--resume &lt;sessionId&gt;</code> for resume - Codex:   <code>exec resume &lt;id&gt;</code> subcommand</p> <p>Using native sessions provides optimal performance as the provider handles context storage and management.</p> Example <pre><code>session = SessionManager(\"claude\")\n\n# First call - creates new session\nflags = session.get_session_flags()\n# Returns: [\"--session-id\", \"uuid-here\"]\n\nsession.call_count = 1\n\n# Subsequent calls - resume session\nflags = session.get_session_flags()\n# Returns: [\"-r\", \"uuid-here\"]\n</code></pre> <p>Attributes:</p> Name Type Description <code>provider</code> <code>Provider</code> <p>The CLI provider being used.</p> <code>session_id</code> <code>str</code> <p>Unique identifier for this session.</p> <code>call_count</code> <code>int</code> <p>Number of calls made in this session.</p> Source code in <code>determinagent/sessions.py</code> <pre><code>class SessionManager:\n    \"\"\"\n    Manages CLI sessions using native provider capabilities.\n\n    All four supported CLIs have native session support:\n    - Claude:  `--session-id &lt;uuid&gt;`, `-r &lt;uuid&gt;` for resume\n    - Gemini:  `--resume &lt;uuid&gt;` for resume\n    - Copilot: `--resume &lt;sessionId&gt;` for resume\n    - Codex:   `exec resume &lt;id&gt;` subcommand\n\n    Using native sessions provides optimal performance as the provider\n    handles context storage and management.\n\n    Example:\n        ```python\n        session = SessionManager(\"claude\")\n\n        # First call - creates new session\n        flags = session.get_session_flags()\n        # Returns: [\"--session-id\", \"uuid-here\"]\n\n        session.call_count = 1\n\n        # Subsequent calls - resume session\n        flags = session.get_session_flags()\n        # Returns: [\"-r\", \"uuid-here\"]\n        ```\n\n    Attributes:\n        provider: The CLI provider being used.\n        session_id: Unique identifier for this session.\n        call_count: Number of calls made in this session.\n    \"\"\"\n\n    def __init__(\n        self,\n        provider: Provider,\n        session_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a session manager.\n\n        Args:\n            provider: CLI provider (claude, gemini, copilot, codex).\n            session_id: Optional explicit session ID. If not provided,\n                       a new UUID will be generated.\n        \"\"\"\n        self.provider: Provider = provider\n        self.session_id: str = session_id or str(uuid.uuid4())\n        self.call_count: int = 0\n\n    def get_session_flags(\n        self,\n        is_first_call: bool | None = None,\n    ) -&gt; list[str]:\n        \"\"\"\n        Return provider-specific session flags.\n\n        Each provider has its own syntax for session management:\n        - Claude: `--session-id &lt;uuid&gt;` for first call, `-r &lt;uuid&gt;` for resume\n        - Gemini: (none) for first call, `--resume &lt;uuid&gt;` for resume\n        - Copilot: (none) for first call, `--resume &lt;id&gt;` for resume\n        - Codex: Returns `[\"resume\", \"&lt;id&gt;\"]` which the adapter handles\n\n        Args:\n            is_first_call: Override for first-call detection. If None,\n                          uses `call_count == 0` to determine.\n\n        Returns:\n            List of CLI flags for session management.\n\n        Note:\n            For Codex, the adapter (not session manager) handles the\n            subcommand structure (`exec` vs `exec resume &lt;id&gt;`).\n        \"\"\"\n        if is_first_call is None:\n            is_first_call = self.call_count == 0\n\n        if self.provider == \"claude\":\n            if is_first_call:\n                return [\"--session-id\", self.session_id]\n            else:\n                return [\"-r\", self.session_id]\n\n        elif self.provider == \"gemini\":\n            if is_first_call:\n                return []  # Gemini auto-creates session\n            else:\n                return [\"--resume\", self.session_id]\n\n        elif self.provider == \"copilot\":\n            if is_first_call:\n                return []  # Copilot auto-creates session\n            else:\n                return [\"--resume\", self.session_id]\n\n        elif self.provider == \"codex\":\n            # Codex uses subcommands, not flags\n            # The adapter handles \"exec\" vs \"exec resume &lt;id&gt;\"\n            if is_first_call:\n                return []\n            else:\n                return [\"resume\", self.session_id]\n\n        return []\n\n    def build_prompt(self, prompt: str) -&gt; str:\n        \"\"\"\n        Build the prompt with any session-specific modifications.\n\n        For native sessions, no modification is needed as the provider\n        handles context persistence.\n\n        Args:\n            prompt: The original prompt text.\n\n        Returns:\n            The prompt (unmodified for native sessions).\n        \"\"\"\n        # Native sessions don't need prompt modification\n        return prompt\n\n    def save_exchange(self, prompt: str, response: str) -&gt; None:\n        \"\"\"\n        Save an exchange to session history.\n\n        For native sessions, this just increments the call count\n        as the provider handles actual storage.\n\n        Args:\n            prompt: The prompt that was sent.\n            response: The response that was received.\n\n        Note:\n            For file-based sessions (not yet implemented), this would\n            save the exchange to the session file.\n        \"\"\"\n        self.call_count += 1\n\n    def reset_session(self) -&gt; None:\n        \"\"\"\n        Reset to a new session.\n\n        Generates a new session ID and resets the call count,\n        effectively starting a fresh conversation.\n        \"\"\"\n        self.session_id = str(uuid.uuid4())\n        self.call_count = 0\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return string representation for debugging.\"\"\"\n        return (\n            f\"SessionManager(provider={self.provider!r}, \"\n            f\"session_id={self.session_id!r}, \"\n            f\"call_count={self.call_count})\"\n        )\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.__init__","title":"<code>__init__(provider, session_id=None)</code>","text":"<p>Initialize a session manager.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>Provider</code> <p>CLI provider (claude, gemini, copilot, codex).</p> required <code>session_id</code> <code>str | None</code> <p>Optional explicit session ID. If not provided,        a new UUID will be generated.</p> <code>None</code> Source code in <code>determinagent/sessions.py</code> <pre><code>def __init__(\n    self,\n    provider: Provider,\n    session_id: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a session manager.\n\n    Args:\n        provider: CLI provider (claude, gemini, copilot, codex).\n        session_id: Optional explicit session ID. If not provided,\n                   a new UUID will be generated.\n    \"\"\"\n    self.provider: Provider = provider\n    self.session_id: str = session_id or str(uuid.uuid4())\n    self.call_count: int = 0\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.__repr__","title":"<code>__repr__()</code>","text":"<p>Return string representation for debugging.</p> Source code in <code>determinagent/sessions.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation for debugging.\"\"\"\n    return (\n        f\"SessionManager(provider={self.provider!r}, \"\n        f\"session_id={self.session_id!r}, \"\n        f\"call_count={self.call_count})\"\n    )\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.build_prompt","title":"<code>build_prompt(prompt)</code>","text":"<p>Build the prompt with any session-specific modifications.</p> <p>For native sessions, no modification is needed as the provider handles context persistence.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The original prompt text.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The prompt (unmodified for native sessions).</p> Source code in <code>determinagent/sessions.py</code> <pre><code>def build_prompt(self, prompt: str) -&gt; str:\n    \"\"\"\n    Build the prompt with any session-specific modifications.\n\n    For native sessions, no modification is needed as the provider\n    handles context persistence.\n\n    Args:\n        prompt: The original prompt text.\n\n    Returns:\n        The prompt (unmodified for native sessions).\n    \"\"\"\n    # Native sessions don't need prompt modification\n    return prompt\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.get_session_flags","title":"<code>get_session_flags(is_first_call=None)</code>","text":"<p>Return provider-specific session flags.</p> <p>Each provider has its own syntax for session management: - Claude: <code>--session-id &lt;uuid&gt;</code> for first call, <code>-r &lt;uuid&gt;</code> for resume - Gemini: (none) for first call, <code>--resume &lt;uuid&gt;</code> for resume - Copilot: (none) for first call, <code>--resume &lt;id&gt;</code> for resume - Codex: Returns <code>[\"resume\", \"&lt;id&gt;\"]</code> which the adapter handles</p> <p>Parameters:</p> Name Type Description Default <code>is_first_call</code> <code>bool | None</code> <p>Override for first-call detection. If None,           uses <code>call_count == 0</code> to determine.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of CLI flags for session management.</p> Note <p>For Codex, the adapter (not session manager) handles the subcommand structure (<code>exec</code> vs <code>exec resume &lt;id&gt;</code>).</p> Source code in <code>determinagent/sessions.py</code> <pre><code>def get_session_flags(\n    self,\n    is_first_call: bool | None = None,\n) -&gt; list[str]:\n    \"\"\"\n    Return provider-specific session flags.\n\n    Each provider has its own syntax for session management:\n    - Claude: `--session-id &lt;uuid&gt;` for first call, `-r &lt;uuid&gt;` for resume\n    - Gemini: (none) for first call, `--resume &lt;uuid&gt;` for resume\n    - Copilot: (none) for first call, `--resume &lt;id&gt;` for resume\n    - Codex: Returns `[\"resume\", \"&lt;id&gt;\"]` which the adapter handles\n\n    Args:\n        is_first_call: Override for first-call detection. If None,\n                      uses `call_count == 0` to determine.\n\n    Returns:\n        List of CLI flags for session management.\n\n    Note:\n        For Codex, the adapter (not session manager) handles the\n        subcommand structure (`exec` vs `exec resume &lt;id&gt;`).\n    \"\"\"\n    if is_first_call is None:\n        is_first_call = self.call_count == 0\n\n    if self.provider == \"claude\":\n        if is_first_call:\n            return [\"--session-id\", self.session_id]\n        else:\n            return [\"-r\", self.session_id]\n\n    elif self.provider == \"gemini\":\n        if is_first_call:\n            return []  # Gemini auto-creates session\n        else:\n            return [\"--resume\", self.session_id]\n\n    elif self.provider == \"copilot\":\n        if is_first_call:\n            return []  # Copilot auto-creates session\n        else:\n            return [\"--resume\", self.session_id]\n\n    elif self.provider == \"codex\":\n        # Codex uses subcommands, not flags\n        # The adapter handles \"exec\" vs \"exec resume &lt;id&gt;\"\n        if is_first_call:\n            return []\n        else:\n            return [\"resume\", self.session_id]\n\n    return []\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.reset_session","title":"<code>reset_session()</code>","text":"<p>Reset to a new session.</p> <p>Generates a new session ID and resets the call count, effectively starting a fresh conversation.</p> Source code in <code>determinagent/sessions.py</code> <pre><code>def reset_session(self) -&gt; None:\n    \"\"\"\n    Reset to a new session.\n\n    Generates a new session ID and resets the call count,\n    effectively starting a fresh conversation.\n    \"\"\"\n    self.session_id = str(uuid.uuid4())\n    self.call_count = 0\n</code></pre>"},{"location":"api/sessions/#determinagent.sessions.SessionManager.save_exchange","title":"<code>save_exchange(prompt, response)</code>","text":"<p>Save an exchange to session history.</p> <p>For native sessions, this just increments the call count as the provider handles actual storage.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt that was sent.</p> required <code>response</code> <code>str</code> <p>The response that was received.</p> required Note <p>For file-based sessions (not yet implemented), this would save the exchange to the session file.</p> Source code in <code>determinagent/sessions.py</code> <pre><code>def save_exchange(self, prompt: str, response: str) -&gt; None:\n    \"\"\"\n    Save an exchange to session history.\n\n    For native sessions, this just increments the call count\n    as the provider handles actual storage.\n\n    Args:\n        prompt: The prompt that was sent.\n        response: The response that was received.\n\n    Note:\n        For file-based sessions (not yet implemented), this would\n        save the exchange to the session file.\n    \"\"\"\n    self.call_count += 1\n</code></pre>"},{"location":"tutorials/first_flow/","title":"How to Write Your First Flow","text":"<p>This tutorial guides you through creating a custom multi-agent workflow using DeterminAgent. By the end, you'll have a working flow that uses multiple AI agents in a coordinated pipeline.</p>"},{"location":"tutorials/first_flow/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>Python 3.10+ installed</li> <li>DeterminAgent installed: <code>pip install determinagent</code></li> <li>At least one CLI tool authenticated:</li> <li>Claude Code (<code>claude</code>)</li> <li>GitHub Copilot CLI (<code>gh copilot</code>)</li> <li>Gemini CLI (<code>gemini</code>)</li> <li>OpenAI Codex (<code>codex</code>)</li> </ul> <p>Verify your CLI is working:</p> <pre><code>claude --version     # or your preferred tool\n</code></pre>"},{"location":"tutorials/first_flow/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new directory for your flow:</p> <pre><code>mkdir my-first-flow\ncd my-first-flow\n</code></pre> <p>Create the main Python file:</p> <pre><code>touch main.py\n</code></pre>"},{"location":"tutorials/first_flow/#step-2-understanding-the-core-components","title":"Step 2: Understanding the Core Components","text":"<p>DeterminAgent has three core building blocks:</p>"},{"location":"tutorials/first_flow/#1-sessionmanager","title":"1. SessionManager","text":"<p>Maintains conversation context across multiple calls to the same agent.</p> <pre><code>from determinagent import SessionManager\n\nsession = SessionManager(\"claude\")  # Provider name\n</code></pre>"},{"location":"tutorials/first_flow/#2-unifiedagent","title":"2. UnifiedAgent","text":"<p>The main interface for sending prompts to AI CLI tools.</p> <pre><code>from determinagent import UnifiedAgent, SessionManager\n\nagent = UnifiedAgent(\n    provider=\"claude\",           # CLI to use\n    model=\"balanced\",            # Model alias: fast, balanced, powerful\n    role=\"assistant\",            # Role name for logging\n    instructions=\"Be helpful.\",  # System prompt\n    session=SessionManager(\"claude\"),\n)\n</code></pre>"},{"location":"tutorials/first_flow/#3-send-method","title":"3. send() Method","text":"<p>Send prompts and receive responses:</p> <pre><code>response = agent.send(\"Explain LangGraph in 3 sentences.\")\nprint(response)\n</code></pre>"},{"location":"tutorials/first_flow/#step-3-create-a-simple-two-agent-flow","title":"Step 3: Create a Simple Two-Agent Flow","text":"<p>Let's build a flow with a Writer agent and an Editor agent.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"My First DeterminAgent Flow: Writer + Editor Pipeline.\"\"\"\n\nfrom determinagent import UnifiedAgent, SessionManager\n\n\ndef create_writer() -&gt; UnifiedAgent:\n    \"\"\"Create the Writer agent.\"\"\"\n    return UnifiedAgent(\n        provider=\"claude\",\n        model=\"balanced\",\n        role=\"writer\",\n        instructions=\"\"\"You are a skilled technical writer.\n        Write clear, engaging content with proper structure.\n        Use markdown formatting for headers and code blocks.\"\"\",\n        session=SessionManager(\"claude\"),\n    )\n\n\ndef create_editor() -&gt; UnifiedAgent:\n    \"\"\"Create the Editor agent.\"\"\"\n    return UnifiedAgent(\n        provider=\"claude\",\n        model=\"balanced\",\n        role=\"editor\",\n        instructions=\"\"\"You are a meticulous editor.\n        Review content for clarity, grammar, and structure.\n        Provide the improved version directly, not just suggestions.\"\"\",\n        session=SessionManager(\"claude\"),\n    )\n\n\ndef run_flow(topic: str) -&gt; str:\n    \"\"\"Run the Writer \u2192 Editor pipeline.\"\"\"\n\n    # Step 1: Writer creates initial draft\n    print(\"\ud83d\udcdd Writer creating draft...\")\n    writer = create_writer()\n    draft = writer.send(f\"Write a 200-word article about: {topic}\")\n    print(f\"Draft complete ({len(draft)} chars)\")\n\n    # Step 2: Editor refines the draft\n    print(\"\\n\u270f\ufe0f Editor refining...\")\n    editor = create_editor()\n    final = editor.send(f\"Edit and improve this article:\\n\\n{draft}\")\n    print(f\"Editing complete ({len(final)} chars)\")\n\n    return final\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    topic = sys.argv[1] if len(sys.argv) &gt; 1 else \"Python async programming\"\n\n    print(f\"\ud83d\ude80 Starting flow for topic: {topic}\\n\")\n    result = run_flow(topic)\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"\ud83d\udcc4 FINAL ARTICLE:\")\n    print(\"=\" * 50)\n    print(result)\n</code></pre> <p>Run your flow:</p> <pre><code>python main.py \"Introduction to LangGraph\"\n</code></pre>"},{"location":"tutorials/first_flow/#step-4-add-configuration-with-yaml","title":"Step 4: Add Configuration with YAML","text":"<p>Create <code>agents.yaml</code> for configurable defaults:</p> <pre><code># agents.yaml - Agent configuration for my flow\ndefaults:\n  writer:\n    provider: claude\n    model: balanced\n  editor:\n    provider: claude\n    model: balanced\n\nsettings:\n  max_retries: 2\n  timeout: 120\n</code></pre> <p>Update your Python code to use the config:</p> <pre><code>from determinagent import UnifiedAgent, SessionManager, load_config\n\ndef create_agents_from_config():\n    \"\"\"Load agents from YAML configuration.\"\"\"\n    config = load_config(\"agents.yaml\")\n\n    writer_cfg = config[\"defaults\"][\"writer\"]\n    editor_cfg = config[\"defaults\"][\"editor\"]\n\n    writer = UnifiedAgent(\n        provider=writer_cfg[\"provider\"],\n        model=writer_cfg[\"model\"],\n        role=\"writer\",\n        instructions=\"...\",  # Your instructions\n        session=SessionManager(writer_cfg[\"provider\"]),\n    )\n\n    editor = UnifiedAgent(\n        provider=editor_cfg[\"provider\"],\n        model=editor_cfg[\"model\"],\n        role=\"editor\",\n        instructions=\"...\",\n        session=SessionManager(editor_cfg[\"provider\"]),\n    )\n\n    return writer, editor\n</code></pre>"},{"location":"tutorials/first_flow/#step-5-add-cli-arguments","title":"Step 5: Add CLI Arguments","text":"<p>Make your flow user-friendly with argparse:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"My First Flow - with CLI arguments.\"\"\"\n\nimport argparse\nfrom determinagent import UnifiedAgent, SessionManager\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(\n        description=\"Run Writer \u2192 Editor pipeline\"\n    )\n    parser.add_argument(\n        \"topic\",\n        help=\"Topic to write about\"\n    )\n    parser.add_argument(\n        \"--writer-provider\",\n        default=\"claude\",\n        choices=[\"claude\", \"copilot\", \"gemini\", \"codex\"],\n        help=\"Provider for the Writer agent\"\n    )\n    parser.add_argument(\n        \"--editor-provider\",\n        default=\"claude\",\n        choices=[\"claude\", \"copilot\", \"gemini\", \"codex\"],\n        help=\"Provider for the Editor agent\"\n    )\n    parser.add_argument(\n        \"--model\",\n        default=\"balanced\",\n        choices=[\"fast\", \"balanced\", \"powerful\"],\n        help=\"Model tier to use\"\n    )\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n\n    writer = UnifiedAgent(\n        provider=args.writer_provider,\n        model=args.model,\n        role=\"writer\",\n        instructions=\"You are a skilled writer.\",\n        session=SessionManager(args.writer_provider),\n    )\n\n    editor = UnifiedAgent(\n        provider=args.editor_provider,\n        model=args.model,\n        role=\"editor\",\n        instructions=\"You are a meticulous editor.\",\n        session=SessionManager(args.editor_provider),\n    )\n\n    print(f\"\ud83d\udcdd Writing about: {args.topic}\")\n    draft = writer.send(f\"Write a 200-word article about: {args.topic}\")\n\n    print(\"\u270f\ufe0f Editing...\")\n    final = editor.send(f\"Improve this article:\\n\\n{draft}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(final)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Now you can run with different providers:</p> <pre><code>python main.py \"Async Python\" --writer-provider claude --editor-provider copilot\n</code></pre>"},{"location":"tutorials/first_flow/#step-6-add-error-handling","title":"Step 6: Add Error Handling","text":"<p>DeterminAgent provides a unified exception hierarchy:</p> <pre><code>from determinagent import (\n    UnifiedAgent,\n    SessionManager,\n    # Exceptions\n    DeterminAgentError,\n    ProviderNotAvailable,\n    ProviderAuthError,\n    TimeoutError,\n    RateLimitExceeded,\n)\n\n\ndef safe_send(agent: UnifiedAgent, prompt: str) -&gt; str | None:\n    \"\"\"Send prompt with comprehensive error handling.\"\"\"\n    try:\n        return agent.send(prompt, timeout=120)\n\n    except ProviderNotAvailable as e:\n        print(f\"\u274c CLI tool not found: {e}\")\n        print(\"   Install the CLI and add to PATH\")\n        return None\n\n    except ProviderAuthError as e:\n        print(f\"\u274c Authentication failed: {e}\")\n        print(\"   Run 'claude login' or equivalent\")\n        return None\n\n    except TimeoutError as e:\n        print(f\"\u23f1\ufe0f Request timed out: {e}\")\n        return None\n\n    except RateLimitExceeded as e:\n        print(f\"\ud83d\udea6 Rate limit hit: {e}\")\n        return None\n\n    except DeterminAgentError as e:\n        print(f\"\u274c Agent error: {e}\")\n        return None\n</code></pre>"},{"location":"tutorials/first_flow/#step-7-add-langgraph-state-machine-advanced","title":"Step 7: Add LangGraph State Machine (Advanced)","text":"<p>For complex workflows, use LangGraph for state management:</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Advanced Flow with LangGraph State Machine.\"\"\"\n\nfrom typing import TypedDict\nfrom langgraph.graph import StateGraph, END\nfrom determinagent import UnifiedAgent, SessionManager\n\n\nclass FlowState(TypedDict):\n    \"\"\"State passed between nodes.\"\"\"\n    topic: str\n    draft: str\n    edited: str\n    revision_count: int\n    approved: bool\n\n\ndef writer_node(state: FlowState) -&gt; FlowState:\n    \"\"\"Writer creates the initial draft.\"\"\"\n    writer = UnifiedAgent(\n        provider=\"claude\",\n        model=\"balanced\",\n        role=\"writer\",\n        instructions=\"\"\"You are a skilled technical writer.\n        Write clear, engaging content with proper structure.\n        Use markdown formatting for headers and code blocks.\"\"\",\n        session=SessionManager(\"claude\"),\n    )\n\n    draft = writer.send(f\"Write a 200-word article about: {state['topic']}\")\n    return {**state, \"draft\": draft}\n\n\ndef editor_node(state: FlowState) -&gt; FlowState:\n    \"\"\"Editor reviews and improves the draft.\"\"\"\n    editor = UnifiedAgent(\n        provider=\"claude\",\n        model=\"balanced\",\n        role=\"editor\",\n        instructions=\"\"\"You are a meticulous editor.\n        Review content for clarity, grammar, and structure.\n        Provide the improved version directly, not just suggestions.\"\"\",\n        session=SessionManager(\"claude\"),\n    )\n\n    edited = editor.send(f\"Edit this article:\\n\\n{state['draft']}\")\n    return {\n        **state,\n        \"edited\": edited,\n        \"revision_count\": state[\"revision_count\"] + 1,\n    }\n\n\ndef review_decision(state: FlowState) -&gt; str:\n    \"\"\"Decide: approve or revise again.\"\"\"\n    # Auto-approve after 2 revisions (customize as needed)\n    if state[\"revision_count\"] &gt;= 2:\n        return \"approve\"\n\n    # In practice, you'd have a reviewer agent or human check\n    return \"approve\"\n\n\n# Build the graph\nworkflow = StateGraph(FlowState)\n\n# Add nodes\nworkflow.add_node(\"write\", writer_node)\nworkflow.add_node(\"edit\", editor_node)\n\n# Add edges\nworkflow.set_entry_point(\"write\")\nworkflow.add_edge(\"write\", \"edit\")\nworkflow.add_conditional_edges(\n    \"edit\",\n    review_decision,\n    {\n        \"approve\": END,\n        \"revise\": \"write\",  # Loop back to writer\n    }\n)\n\n# Compile\napp = workflow.compile()\n\n\ndef run_langgraph_flow(topic: str) -&gt; str:\n    \"\"\"Run the LangGraph-based flow.\"\"\"\n    initial_state: FlowState = {\n        \"topic\": topic,\n        \"draft\": \"\",\n        \"edited\": \"\",\n        \"revision_count\": 0,\n        \"approved\": False,\n    }\n\n    result = app.invoke(initial_state)\n    return result[\"edited\"]\n\n\nif __name__ == \"__main__\":\n    import sys\n    topic = sys.argv[1] if len(sys.argv) &gt; 1 else \"Introduction to DeterminAgent\"\n\n    print(f\"\ud83d\ude80 Running LangGraph flow: {topic}\\n\")\n    final = run_langgraph_flow(topic)\n    print(\"\\n\ud83d\udcc4 Final Article:\\n\")\n    print(final)\n</code></pre>"},{"location":"tutorials/first_flow/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built your first DeterminAgent flow. Here's what to explore next:</p> <ol> <li> <p>Study the Blog Flow: See <code>flows/blog/</code> for a production-ready example with human review loops.</p> </li> <li> <p>Try Different Providers: Mix providers for different roles (e.g., Claude for writing, Copilot for code).</p> </li> <li> <p>Add Structured Output: Use <code>agent.send_structured()</code> with Pydantic models for typed responses.</p> </li> <li> <p>Explore Session Management: Use the same session across a conversation for context continuity.</p> </li> </ol>"},{"location":"tutorials/first_flow/#resources","title":"Resources","text":"<ul> <li>Architecture: Deep dive into the library internals</li> <li>CLI Reference: Provider-specific flag mappings</li> <li>API Documentation: Full API reference</li> <li>Blog Flow Example: Complete production flow</li> </ul> <p>Need help? Open an issue on GitHub.</p>"}]}